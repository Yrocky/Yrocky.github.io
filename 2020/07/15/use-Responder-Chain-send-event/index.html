<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">基于Responder Chain的对象交互</h1><div class="post-info">2020 7月 15日</div><div class="post-entry"><h2 id="问题">问题</h2><p>在直播间中对视图进行解耦的时候，遇到了一个问题：</p>
<blockquote>
<p>因为是将具体业务视图放到对应的contentView中，并且这些业务视图的事件接收方还是当前视图控制器，就会造成事件的传递需要透过contentView这一层。</p>
</blockquote>
<p>如果中间只有contentView这一层还好，可以使用一个多余的delegate或者block将事件转换一下，但如果业务视图自己中也有其他的子控件需要传递事件到视图控制器，那就不止一层了。在软件开发中，只有变和不变，在这里就是如果他有一层，那么就可能有n多层，为了一层提出的方案在n多层中就会显得不那么适用，因为这样并没有解决根本问题。</p>
<img src="/2020/07/15/use-Responder-Chain-send-event/ResponderChain.png" title="ResponderChain">
<p>当然使用通知可以无视事件触发层和处理层之间的距离，但是，通知在我看来不是一个很好的UI通信方式，并且满天飞的通知很难管理。</p>
<a id="more"></a>
<h2 id="normal">normal</h2><p>先说一下以前都是怎么处理多层事件传递的，主要有两种方式。</p>
<p>第一种做法是为contentView添加一个代理，这个代理继承至其子视图们的代理，由于协议是可以多继承，因此可以这么写，但是这样就会暴露这个contentView内部的子视图，不符合封装的特性，没有很好的体现这个contentView的封装性。</p>
<img src="/2020/07/15/use-Responder-Chain-send-event/normal_1.png" title="normal_1">
<p>这样的做法比较省心，不需要写很多的无用代理方法，缺点就是上面提到的暴露了内部的类。</p>
<p>另一种做法是在contentView内部对子视图做一个代理传递，自己统一代理协议的接口：</p>
<img src="/2020/07/15/use-Responder-Chain-send-event/normal_2.png" title="normal_2">
<p>内部将子视图的代理回调方法传递给自己的代理：</p>
<img src="/2020/07/15/use-Responder-Chain-send-event/normal_3.png" title="normal_2">
<p>这个做法的好处一个是代理接口统一，另外就是可以在子视图的代理回调里面做一些contentView的业务处理，灵活性更高一些。</p>
<p>缺点就是需要写好多代理方法以及传递子视图的代理给contentVIew的代理，并且如果嵌套层级过深写起来就会很不优雅。</p>
<p>那么有没有一个很优雅的方法来解决这个难题呢？</p>
<h2 id="Responder_Chain">Responder Chain</h2><p>这个方案是从<a href="https://casatwy.com/responder_chain_communication.html" target="_blank" rel="noopener">casatwy</a>那里看到的，基于响应链来实现，具体介绍可以参考作者的文章，主要思路就是为UIResponder添加一个分类方法，将要传递的数据交给其nextResponder，直到多层之后的控制器，控制器可以重写该分类方法来实现具体的业务逻辑。</p>
<p>由于在响应链中事件的传递是自上而下的，也就是先从点击的控件开始再到其所在的contentView，然后再到LivingRoomVC。</p>
<img src="/2020/07/15/use-Responder-Chain-send-event/ResponderChain_casatwy.png" title="ResponderChain_casatwy">
<p>这个方案可以解决多UI层级下的事件传递，但是不能解决反向数据代理，比如深层的UI需要控制器通过代理（确切点叫数据源）来返回数据，当然在业务中比较多的还是控件之间的事件传递，而且作者也说了这个模式只能处理基于响应链的事件传递。</p>
<p>基于响应链的方案，只需要为UIResponder添加一个分类方法，将对应的事件交给<code>nextResponder</code>，因此中间的响应者还可以根据业务需求针对不同的事件进行添加或者修改等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface UIResponder (EventRouter)</span><br><span class="line"></span><br><span class="line">- (void) routerEventWithName:(NSString *)eventName;</span><br><span class="line">- (void) routerEventWithName:(NSString *)eventName userInfo:(nullable NSDictionary *)userInfo;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation UIResponder (EventRouter)</span><br><span class="line"></span><br><span class="line">- (void) routerEventWithName:(NSString *)eventName userInfo:(nullable NSDictionary *)userInfo&#123;</span><br><span class="line">    if (nil != eventName) &#123;</span><br><span class="line">        [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>将业务事件使用一个<code>EventProxy</code>抽离于视图控制器之外，内部使用一个<code>集合</code>来存储策略，然后在视图控制器将对应事件交给EventProxy的时候做消息转发，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@interface EventProxy()</span><br><span class="line">@property (nonatomic, copy) NSSet&lt;NSValue *&gt; *eventStrategy;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EventProxy</span><br><span class="line"></span><br><span class="line">- (void)handleEvent:(NSString *)eventName userInfo:(NSDictionary *)userInfo&#123;</span><br><span class="line">    </span><br><span class="line">    __block NSDictionary * strongUserInfo = userInfo;</span><br><span class="line">    [self.eventStrategy enumerateObjectsUsingBlock:^(NSValue * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        // EventWrap是一个用来包裹event-action的私有结构体</span><br><span class="line">        EventWrap event = EventWrapFromNSValue(obj);</span><br><span class="line">        if ([event.name isEqualToString:eventName]) &#123;</span><br><span class="line">            NSInvocation *invocation = [self createInvocationWithSelector:event.method];</span><br><span class="line">            if (invocation) &#123;</span><br><span class="line">                if (invocation.methodSignature.numberOfArguments &gt; 2) &#123;</span><br><span class="line">                    [invocation setArgument:&amp;strongUserInfo atIndex:2];</span><br><span class="line">                &#125;</span><br><span class="line">                [invocation invoke];</span><br><span class="line">            &#125;</span><br><span class="line">            *stop = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>视图控制器的子视图通过直接调用<code>-routerEventWithName:userInfo:</code>方法发送事件，可选针对事件传递一些附加数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// in a subView of ViewController .m</span><br><span class="line">- (void) onButton&#123;</span><br><span class="line">    [self routerEventWithName:@&quot;sub-view-button-click&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类化一个EventProxy，并且预先添加好所有的业务策略，然后成为视图控制器的属性，在控制器的<code>-routerEventWithName:userInfo:</code>方法中将对应的事件交给子类EventProxy，由于父类EventProxy中已经在<code>-handleEvent:userInfo:</code>方法中做了对应的事件映射，所以这里可以直接将子类创建的action和对应的event进行绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@implementation XXXLivingRoomEventProxy</span><br><span class="line"></span><br><span class="line">-(instancetype)initWithController:(__kindof UIViewController *)controller&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.controller = controller;</span><br><span class="line">        _eventStrategy = [NSSet setWithArray:(&#123;</span><br><span class="line">            @[NSValueFromEventAndMethod(@&quot;sub-view-button-click&quot;,</span><br><span class="line">                                        @selector(onSubViewButtonClick))</span><br><span class="line">        &#125;)];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) onSubViewButtonClick&#123;</span><br><span class="line">    NSLog(@&quot;onSubViewButtonClick&quot;);</span><br><span class="line">    [self.controller presentViewController:(&#123;</span><br><span class="line">        UIAlertController * alert = [UIAlertController alertControllerWithTitle:@&quot;Title&quot; message:@&quot;Message&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        [alert addAction:(&#123;</span><br><span class="line">            [UIAlertAction actionWithTitle:@&quot;Sure&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                NSLog(@&quot;alert sure&quot;);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;)];</span><br><span class="line">        alert;</span><br><span class="line">    &#125;) animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2><ul>
<li><a href="https://casatwy.com/responder_chain_communication.html" target="_blank" rel="noopener">https://casatwy.com/responder_chain_communication.html</a></li>
<li><a href="https://github.com/Yrocky/Weather_App/blob/develop/articles/ResponderChain.md" target="_blank" rel="noopener">https://github.com/Yrocky/Weather_App/blob/develop/articles/ResponderChain.md</a></li>
</ul>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></article></div><div class="post-nav"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/2021/01/12/before-state-and-data-flow/" class="prev-post">SwiftUI中的Data Flow（一）</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/2020/07/15/use-Self-Manager-make-Module/" class="next-post">Self-Manager模式在业务开发中的组件化应用</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>