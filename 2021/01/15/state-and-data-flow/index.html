<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">SwiftUI中的Data Flow（二）</h1><div class="post-info">2021 1月 15日</div><div class="post-entry"><p>我们在SwiftUI中修改数据，依赖这些数据的UI就会自动更新出来最新的值，这看起来很神奇，但是如果你看了前文之后，就多多少少会猜测到一些，我们统称这为Data Flow。在SwiftUI中，Data Flow是一个很重要很核心的概念，在我们实际的开发中，需要合理的管理自己的data flow，以确保我们拥有唯一的数据源（source of truth）。</p>
<p>在UIKit中，我们使用的是命令式的编程方式（imperative programming），比如前文中ModelY的属性发生变动，需要同步手动的更新我们的ModelYView。SwiftUI则采用一种声明式的编程方式（declarative programming），轻量化视图，让我们只关注会发生变化的数据，Data Flow会来完成数据与视图之间的依赖绑定，从而将最新的状态更新到视图上。在这种方式下，如果数据发生变化，SwiftUI根据数据重新构建视图，并以一种高效的diff算法来最小化的变动视图结构，这不在我们本文的讨论范围。</p>
<a id="more"></a>
<p>下面我们会从一个小例子开始，逐步的学习了解SwiftUI中构建一个合理的Data Flow所提供的一些工具。</p>
<h3 id="@State">@State</h3><p>我们可以像往常一样，在某些控件中使用变量来展示数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello <span class="subst">\(text)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里text是一个静态的数据，如果我们会改动该数据，比如下面添加一个Button，然后修改text，会发现编译报错。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"World"</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Text</span>(<span class="string">"Hello <span class="subst">\(text)</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">Button</span>(<span class="string">"Modif"</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.text = <span class="string">"世界"</span><span class="comment">// ERROR: Cannot assign to property: 'self' is immutable</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Struct是不可变的值类型，并且我们不可以在计算属性中修改变量，这个时候需要使用@State来标记text。根据前文我们知道，在修改text的时候，State内部会进入到wrappedValue的set方法，在这个方法内部SwiftUI会根据状态的变动计算要修改的范围，重新渲染视图，从而更新与text有依赖的所有视图。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> text = <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">Button</span>(<span class="string">"Modif"</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.text = <span class="string">"世界"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要获取变量最新的状态（值）的时候，我们可以使用@State来标记变量。比如</p>
<p>下面的TextField会改变email的值，Text会显示email最新的值，使用@State我们就完成了控件与变量之间的绑定，但是在TextField中会修改email，并且它的初始化需要一个<code>Binding&lt;String&gt;</code>类型的数据。从前文我们知道State其实是一个<code>Property Wrappers</code>，它的projectedValue是一个<code>Binding类型</code>的数据，因此在这里我们可以使用<code>$email</code>获得到一个Binding<string>的变量，交给TextField进行初始化使用。</string></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> email: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">Text</span>(<span class="string">"Your email is: <span class="subst">\(email)</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">HStack</span>(spacing: <span class="number">8</span>)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">Image</span>(systemName: <span class="string">"envelope"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="type">TextField</span>(<span class="string">"input email"</span>, text: $email)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="@Binding">@Binding</h3><p>基于精简视图的目的，我们将Image和TextField抽离成一个独立的<code>View：InputView</code>，在内部，同样是使用@State将控件和变量进行绑定。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> email: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">Text</span>(<span class="string">"Your email is: <span class="subst">\(email)</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">InputView</span>(icon:<span class="string">"envelope"</span>, placehold: <span class="string">"input email"</span>, text: email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> placehold: <span class="type">String</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HStack</span>(spacing: <span class="number">8</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Image</span>(systemName: icon)</span><br><span class="line"></span><br><span class="line">            <span class="type">TextField</span>(placehold, text: $text)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是通过示例发现，父View并不能将email变量、Text控件与InputView中的text进行绑定，如果要实现父View与子View之间的数据绑定，我们需要使用<code>@Binding</code>来标记子View中的text，同时使用InputView的时候需要传递<code>$email</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in FatherView</span></span><br><span class="line"></span><br><span class="line"><span class="type">InputView</span>(icon:<span class="string">"envelope"</span>, placehold: <span class="string">"input email"</span>, text: $email)</span><br><span class="line"></span><br><span class="line"><span class="comment">// in InputView</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@State var text: String</span></span><br><span class="line">  @<span class="type">Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用State与Binding，我们将InputView以及其子视图(TextField)、父视图之间的email数据完成了双向绑定。每使用@State标记一个属性的时候，其实就创建了一个<code>source of truth</code>，而子视图中的数据需要和父视图中的数据源保持一致，以确保拥有的是<code>唯一source of truth</code>，就需要将两个数据进行绑定，让数据之间形成一个依赖，而不是拥有一个新的数据。而且也不需要提供依赖数据的初始值，因为我们需要从唯一source of truth中获取。</p>
<h3 id="@ObservedObject">@ObservedObject</h3><p>如果现在我们需要使用三个InputView来做一个注册功能，那么就需要有三个@State的变量来分别为InputView提供source of truth。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> account: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> password: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> confirmPassword: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doForm: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">VStack</span>&#123;</span><br><span class="line">    <span class="type">InputView</span>(icon: <span class="string">"person"</span>, placehold: <span class="string">"account"</span>, text: $account)</span><br><span class="line"></span><br><span class="line">    <span class="type">InputView</span>(icon: <span class="string">"lock.square.stack"</span>, placehold: <span class="string">"password"</span>, text: $password)</span><br><span class="line"></span><br><span class="line">    <span class="type">InputView</span>(icon: <span class="string">"lock.square.stack"</span>, placehold: <span class="string">"confirm password"</span>, text: $confirmPassword) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个变量已经算比较多的了，如果变量继续增多，我们还需要继续添加变量，这将不是一个明智的选择。我们应该使用一个类型抽象这个场景下的数据，比如一个SingUpData。结合前文提到的Publisher，这里我们让SingUpData遵守ObservableObject协议，这样我们就可以观察属性的变化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingUpData</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">  @<span class="type">Published</span> <span class="keyword">var</span> account: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  @<span class="type">Published</span> <span class="keyword">var</span> password: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  @<span class="type">Published</span> <span class="keyword">var</span> confirmPassword: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们删除注册需要的三个变量，使用SingUpData来代替，并使用@ObservedObject进行标记。这样在SingUpData有变化的时候，视图都会收到更新，进而重新渲染界面；同样的，在视图中修改SingUpData中的数据（比如account），不仅能同步到SingUpData中，还可以更新界面中的显示（比如Text(“your accout:($singUpData.account)”)）。</p>
<blockquote>
<p>BindableObject 和ObjectBinding已经被删除，替换他们的是与binding没有歧义的ObservableObject、ObservedObject。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">ObservedObject</span> <span class="keyword">private</span> <span class="keyword">var</span> singUpData = <span class="type">SingUpData</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">VStack</span>&#123;</span><br><span class="line">    <span class="type">InputView</span>(icon: <span class="string">"person"</span>, placehold: <span class="string">"account"</span>, text: $singUpData.account)</span><br><span class="line"></span><br><span class="line">    <span class="type">InputView</span>(icon: <span class="string">"lock.square.stack"</span>, placehold: <span class="string">"password"</span>, text: $singUpData.password)</span><br><span class="line"></span><br><span class="line">    <span class="type">InputView</span>(icon: <span class="string">"lock.square.stack"</span>, placehold: <span class="string">"confirm password"</span>, text: $singUpData.confirmPassword) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么不使用@State而使用@ObservedObject">为什么不使用@State而使用@ObservedObject</h3><p>需要注意的是，使用<strong>@ObservedObject标记的必须是引用类型</strong>，这一点和State不同，<strong>@State只能用于标记值类型</strong>，比如String、Int、Bool、Struct、Enum。那你可能会说，将SingUpData换成Struct不就可以使用@State来标记它了么！比如下面这样修改，答案当然是可以的，这正好验证了@State只能标记值类型这个观点。所以使用哪一个来作为source of truth取决于你的数据是什么类型的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> singUpData = <span class="type">SingUpData</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SingUpData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> account: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> password: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> confirmPassword: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果我们在注册界面中添加一个提交按钮，它的状态根据输入的内容来决定，使用<code>disabled(:)</code>可以决定按钮是否可用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingUpData is Struct</span></span><br><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="type">Button</span>(<span class="string">"Commit"</span>) &#123;</span><br><span class="line">    <span class="comment">// singup handle</span></span><br><span class="line">&#125;</span><br><span class="line">.disabled($singupData.account.wrappedValue.<span class="built_in">count</span> &lt; <span class="number">4</span> || $singupData.password.wrappedValue != $singupData.confirmPassword.wrappedValue || $singupData.password.wrappedValue.<span class="built_in">count</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>但是看着参数中一堆的逻辑，我们想着应该将他们放入SingUpData中自己来决定，很遗憾的是，使用一个计算属性来简化逻辑之后，我们预期的效果并没有达到，按钮的状态并不会根据输入发生变化。不仅仅是因为它只是一个计算属性，还在于这个计算属性在外部使用的时候并没有与我们的Data Flow产生依赖。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SingUpData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> disable: <span class="type">Bool</span> &#123;</span><br><span class="line">      account.<span class="built_in">count</span> &lt; <span class="number">4</span> || password != confirmPassword || password.<span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="@Binding-1">@Binding</h3><h3 id="@ObservedObject-1">@ObservedObject</h3><blockquote>
<p>BindableObject 和ObjectBinding已经被删除了，替换他们的是与binding没有歧义的ObservableObject、ObservedObject，这些都是直接以依赖，用于形成子视图与父视图之间的依赖。</p>
</blockquote>
<h3 id="@EnvironmentObject">@EnvironmentObject</h3><p>兄弟视图或者祖父视图与视图之间的依赖关系就需要使用环境变量。EnvironmentObject，</p>
<p>在讲解他之前，我们看一下这样的一个示例，在父视图上使用accentColor或者font，暗夜模式，然后其深层次的子视图中的Text就会响应这些设置。</p>
<h3 id="@Environment">@Environment</h3><h3 id="@StateObject">@StateObject</h3><h2 id="参考文章">参考文章</h2><ul>
<li>参考文章列表</li>
</ul>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/SwiftUI/">SwiftUI</a>, <a class="tag-link" href="/tags/iOS开发/">iOS开发</a></div></article></div><div class="post-nav"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/2021/01/28/use-Binding-make-some-view-great/" class="prev-post">使用Binding创建符合SwiftUI设计理念的组件</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/2021/01/12/before-state-and-data-flow/" class="next-post">SwiftUI中的Data Flow（一）</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>