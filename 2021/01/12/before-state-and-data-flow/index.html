<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">SwiftUI中的Data Flow（一）</h1><div class="post-info">2021 1月 12日</div><div class="post-entry"><p>SwiftUI提供了一个声明式的框架让我们来构建界面，其核心的View只是状态的一个计算属性，而不是UIKit中所真实表示的界面元素。在我们使用View构建界面的时候，还需要指明视图之间的数据依赖关系。这在往常会使用属性来设置依赖，进一步使用响应式框架（RxSwift等）的时候会使用特殊的操作来完成依赖、绑定。在swiftUI中，由于View只是状态的计算属性，而状态是以数据的形式进行存储，所以就需要有个唯一的<code>source of truth</code>来保证各个View与数据的状态保持同步。</p>
<blockquote>
<p>Views are a function of state</p>
</blockquote>
<p>在不同的使用场景下，source of truth可以是<code>@State</code>、<code>@Binding</code>，也可以是<code>@ObservedObject</code>、<code>@EnvironmentObject</code>，甚至是<code>@StateObject</code>。他们功能各不相同，但是他们所运用的核心技术是一样的：<code>Property Wrappers</code>、<code>Dynamic Member Lookup</code>等等。本文在此基础上，先来探讨一些非swiftUI框架下开发遇到的问题，以及使用这些核心技术来解决他们，然后逐步引出swiftUI中要如何设计数据流，为后续章节做铺垫。</p>
<img src="/2021/01/12/before-state-and-data-flow/State_and_Data_Flowx900.png" title="State_and_Data_Flow">
<a id="more"></a>
<h2 id="Property_Wrappers">Property Wrappers</h2><p>在开发中，不论是调试还是做业务，都会遇到需要观察某一个类（Person）中属性（name）改变的需求，一般的做法是重写set方法，当然也有重写get方法的。比如下面通过一个私有属性<code>_name</code>以及<code>重写set方法</code>来输出对应的log：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> _name = <span class="string">"default"</span></span><br><span class="line">   <span class="keyword">var</span> name : <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">get</span> &#123; _name &#125;</span><br><span class="line">       <span class="keyword">set</span> &#123;</span><br><span class="line">           _name = newValue</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"name was changed :<span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在外部使用的时候，只要name有所变动就会有对应的log输出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">person.name = <span class="string">"rocky"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// print: name was changed :rocky</span></span><br></pre></td></tr></table></figure>
<p>这样可以很方便的实现我们的需求：打印、发通知、调用方法等等。但是这样会有一个弊端：一个属性还好，如果有很多属性都需要被观察呢？软件编程中的一个观点是：不要重复的做一件事两次。</p>
<p>这个时候就要对一操作进行抽象封装。</p>
<p>思考一下，_name这个属性本身的作用是<code>对name的wrap</code>，对Person设置name属性的时候其实是设置了_name，因此可以将这个_name进行拓展一下。比如抽象成一个<code>ConsoleLogged</code>的类型，它接受任意要wrapped的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化要wrape的值</span></span><br><span class="line">   <span class="keyword">init</span>(<span class="number">_</span> wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">       <span class="keyword">self</span>.value = wrappedValue</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取被wrape值的真实数据</span></span><br><span class="line">   <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">       <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">       <span class="keyword">set</span> &#123;</span><br><span class="line">           value = newValue</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"value was changed :<span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，修改Person，使用这个ConsoleLogged类型来wrap我们的_name属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> _name = <span class="type">ConsoleLogged</span>&lt;<span class="type">String</span>&gt;(<span class="string">"default"</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">get</span> &#123; _name.wrappedValue &#125;</span><br><span class="line">       <span class="keyword">set</span> &#123; _name.wrappedValue = newValue &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候再测试一下最新的Person类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">person.name = <span class="string">"rocky"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// print: value was changed :rocky</span></span><br></pre></td></tr></table></figure>
<p>目前看来，还不错。</p>
<p>不过，虽然我们封装出了一个具有wrapper功能的ConsoleLogged，但如果属性过多，还是需要编写很多的模板代码。</p>
<p>从iOS13开始，swift为我们提供了一个新特性：<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#projections" target="_blank" rel="noopener">Property Wrappers</a>。这里修改一下我们的ConsoleLogged，使用<code>@propertyWrapper</code>来标记一下，这样它就具备了<code>Property Wrappers</code>所提供的功能了。接下来修改我们的Person，删除内部所有代码，只保留一个属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   @<span class="type">ConsoleLogged</span> <span class="keyword">var</span> name = <span class="string">"default"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在Person中就没有了样板代码，并且测试也是可以正常打印log：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rocky = <span class="type">Person</span>()</span><br><span class="line">rocky.name = <span class="string">"rocky"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// print: value was changed :rocky</span></span><br></pre></td></tr></table></figure>
<p>其实<code>@ConsoleLogged</code>就是一个语法糖，它等价于我们之前在Person中编写的对name的set、get方法的监听，以及一个私有的_name属性这些代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">ConsoleLogged</span> <span class="keyword">var</span> name = <span class="string">"default"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被编译器转化成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _name = <span class="type">ConsoleLogged</span>&lt;<span class="type">String</span>&gt;(<span class="string">"default"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">   <span class="keyword">get</span> &#123; _name.wrappedValue &#125;</span><br><span class="line">   <span class="keyword">set</span> &#123;</span><br><span class="line">       _name.wrappedValue = newValue</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"value was changed :<span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用的是一个struct来作为<code>Property Wrappers</code>，如果现在我们为这个结构体添加一个方法，我们应该如何访问它呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">oop</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"this is some oop func"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们试着编写如下代码会发现编译报错，这是因为我们目前为止，只是通过ConsoleLogged提供了一个被wrapped的数据，并没有提供<code>ConsoleLogged类型本身</code>的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">person.name.oop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: referencing instance method 'oop()' requires wrapper 'ConsoleLogged&lt;String&gt;'</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/12/before-state-and-data-flow/just_name.png" title="just_name">
<p>我们需要为ConsoleLogged提供一个<code>projectedValue</code>属性，通过这个属性我们可以获取到ConsoleLogged实例（当然，并不是规定一定要返回当前类型的实例，也可以是其他类型的实例），从而执行它相关的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">var</span> projectedValue: <span class="type">ConsoleLogged</span>&lt;<span class="type">Value</span>&gt; &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们就可以调用oop方法了，只不过需要使用<code>$name</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">person.$name.oop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// print: this is some oop func</span></span><br></pre></td></tr></table></figure>
<p><code>$name</code>其实也是个语法糖，编译器会自动我们提供一个<code>$name</code>的属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">ConsoleLogged</span> <span class="keyword">var</span> name = <span class="string">"default"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被编译器转化成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _name = <span class="type">ConsoleLogged</span>&lt;<span class="type">String</span>&gt;(<span class="string">"default"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> $name: <span class="type">ConsoleLogged</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name.projectedValue &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">   <span class="keyword">get</span> &#123; _name.wrappedValue &#125;</span><br><span class="line">   <span class="keyword">set</span> &#123;</span><br><span class="line">       _name.wrappedValue = newValue</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"value was changed :<span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上我们会发现，使用@propertyWrapper标记的类型（struct、class、enum）提供备了很强的钩子、甚至转化特性，可以让我们在这些地方做一些特殊的逻辑，比如这里的@ConsoleLogged的log输出，之后的@State、@Binding对数据和View之间的双向绑定等等。</p>
<blockquote>
<p>以上只是我们在接下来会用到的关于<code>Property Wrappers</code>的一些知识点，它还有很多其他的特性，感兴趣的可以查看<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#projections" target="_blank" rel="noopener">SE:0258</a>。</p>
</blockquote>
<h2 id="Publisher">Publisher</h2><p>在使用UIKit编写app的时候，假如我们有一个数据类型（ModelY），并且有一个视图（ModelYView）会根据它来展示具体的内容，我们希望在这个模型有变动的时候（不论任何属性的变动），ModelYView都会同步的渲染出来。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelY</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color: <span class="type">String</span> = <span class="string">"red"</span></span><br><span class="line">  <span class="keyword">var</span> money: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelYView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">var</span> modelY = <span class="type">ModelY</span>()</span><br><span class="line">   <span class="comment">//.. 省略一些控件 ..</span></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">       <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">       modifButton.addTarget(<span class="keyword">self</span>, action: #selector(modifColor), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">       addSubview(modifButton)</span><br><span class="line"></span><br><span class="line">       modelYDesLabel.text = <span class="string">"color:<span class="subst">\(modelY.color)</span>"</span></span><br><span class="line">       addSubview(modelYDesLabel)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">modifColor</span><span class="params">()</span></span> &#123;</span><br><span class="line">       modelY.color = <span class="string">"orange"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常如上的处理并不会生效，结果只是modelY属性有所改动，但是ModelYView并没有将更新体现出来。如果在modelY更新的时候，也同步的更新依赖modelY的控件，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">modifColor</span><span class="params">()</span></span> &#123;</span><br><span class="line">  modelY.color = <span class="string">"orange"</span></span><br><span class="line">  modelYDesLabel.text = <span class="string">"color:<span class="subst">\(modelY.color)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然可以达到目的，但其实并没有达到一种<code>绑定的效果</code>。另外，如果modelY中有更多的属性变动会分别引起不同的控件的展示，就会将逻辑散落在各处。比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  modifMoneyButton.addTarget(<span class="keyword">self</span>, action: #selector(modifMoney), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">  addSubview(modifMoneyButton)</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">modifColor</span><span class="params">()</span></span> &#123;</span><br><span class="line">  modelY.color = <span class="string">"orange"</span></span><br><span class="line">  modelYDesLabel.text = <span class="string">"color:<span class="subst">\(modelY.color)</span> money:<span class="subst">\(modelY.money)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">modifMoney</span><span class="params">()</span></span> &#123;</span><br><span class="line">  modelY.money = <span class="number">34</span></span><br><span class="line">  modelYDesLabel.text = <span class="string">"color:<span class="subst">\(modelY.color)</span> money:<span class="subst">\(modelY.money)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以提供一个updateUI函数统一处理model与view之间的数据依赖。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">let</span> text = <span class="string">"color:<span class="subst">\(modelY.color)</span> money:<span class="subst">\(modelY.money)</span>"</span></span><br><span class="line">   modelYDesLabel.text = text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以在ModelY中统一处理，使用<code>willSet</code>方法监听所有属性的变动，然后将更新以代理、通知或者block的方式通知ModelYView。这些方法本质上和我们上面的方案是一样的，只不过一个是在分发侧（ModelY）统一处理，一个是在接收侧（ModelYView）统一处理，两者并没有形成一个绑定的依赖关系。</p>
<blockquote>
<p>模型中的数据会被拷贝一份到视图上，这样在模型的数据有改动的时候，还需要<code>手动的</code>再次对新数据进行拷贝以使用，同样一份数据，却会存在多处拷贝。</p>
</blockquote>
<p>如果要完成model与view之间的响应式依赖，我们需要一个响应式框架，使用这个框架来完成两者之间的绑定。从iOS13开始，苹果为我们提供了一个官方的响应式框架：<code>Combine</code>。这里我们使用其中的<code>ObservableObject</code>协议，使得我们的分发侧拥有一个Publisher，从而可以在属性有所变动的时候将最新的状态分发出去，这样接收侧就可以根据变动进行对应的界面更新。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ObservableObject</span> : <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The type of publisher that emits before the object has changed.</span></span><br><span class="line">  associatedtype <span class="type">ObjectWillChangePublisher</span> : <span class="type">Publisher</span> = <span class="type">ObservableObjectPublisher</span> <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">ObjectWillChangePublisher</span>.<span class="type">Failure</span> == <span class="type">Never</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// A publisher that emits before the object has changed.</span></span><br><span class="line">  <span class="keyword">var</span> objectWillChange: <span class="type">Self</span>.<span class="type">ObjectWillChangePublisher</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，让我们的ModelY遵守<code>ObservableObject</code>协议，这样它就会拥有一个<code>ObjectWillChangePublisher</code>类型的<code>objectWillChange</code>，使用这个Publisher，我们可以在属性有变动的时候调用它的<code>send</code>进行分发：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelY</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> color: <span class="type">String</span> = <span class="string">"red"</span>&#123; <span class="keyword">willSet</span>&#123; updateUI() &#125; &#125;</span><br><span class="line">  <span class="keyword">var</span> money: <span class="type">Int</span> = <span class="number">0</span> &#123; <span class="keyword">willSet</span>&#123; updateUI() &#125; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">      objectWillChange.send()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么到现在我们已经有了一个<code>分发侧的Publisher</code>，接下来就需要在接收侧进行订阅。在这里，我们使用<code>sink</code>（也可以使用assign直接作用在modelYDesLabel上）来进行订阅，并且在收到消息之后与之前一样，调用<code>updateUI</code>使用最新的modelY更新界面。同时需要去掉在两个target-action方法中对updateUI的调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelYView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">var</span> subscriptions = <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">     <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">     modelY</span><br><span class="line">         .objectWillChange</span><br><span class="line">         .sink &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">             <span class="keyword">self</span>.updateUI()</span><br><span class="line">         &#125;</span><br><span class="line">         .store(<span class="keyword">in</span>: &amp;subscriptions)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">modifColor</span><span class="params">()</span></span> &#123;</span><br><span class="line">     modelY.color = <span class="string">"orange"</span></span><br><span class="line">     <span class="comment">//updateUI()</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">modifMoney</span><span class="params">()</span></span> &#123;</span><br><span class="line">     modelY.money = <span class="number">34</span></span><br><span class="line">     <span class="comment">//updateUI()</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">let</span> text = <span class="string">"color:<span class="subst">\(modelY.color)</span> money:<span class="subst">\(modelY.money)</span>"</span></span><br><span class="line">     modelYDesLabel.text = text</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们已经完成了ModelY发生更新，ModelYView根据最新内容展示界面的任务。不过，使用下来会发现有以下一些问题：</p>
<ul>
<li>对属性的willSet方法监听太过于模板化</li>
<li>接收侧对于事件的监听太不响应式</li>
<li>model与view之间并没有形成双向绑定</li>
</ul>
<p>针对第一个问题，结合上面的<code>Property Wrappers</code>，我们可以使用<code>@Published</code>来优化：使用@Published来标记属性，就省去了过于模板化的分发操作。</p>
<p>Published这个<code>Property Wrappers</code>提供的projectedValue是一个Publisher，也就是说通过Published标记的属性也可以分发。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Published</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">init</span>(initialValue: <span class="type">Value</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">Published</span>&lt;<span class="type">Value</span>&gt;.<span class="type">Publisher</span> &#123; <span class="keyword">mutating</span> <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Publisher</span> : <span class="title">Publisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Output</span> = <span class="type">Value</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Failure</span> = <span class="type">Never</span></span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">receive</span>&lt;S&gt;<span class="params">(subscriber: S)</span></span> <span class="keyword">where</span> <span class="type">Value</span> == <span class="type">S</span>.<span class="type">Input</span>, <span class="type">S</span> : <span class="type">Subscriber</span>, <span class="type">S</span>.<span class="type">Failure</span> == <span class="type">Published</span>&lt;<span class="type">Value</span>&gt;.<span class="type">Publisher</span>.<span class="type">Failure</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为ModelY添加一个使用Published标记的host属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelY</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">   @<span class="type">Published</span> <span class="keyword">var</span> host: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，ModelY有两个Publisher，一个是自身具备的<code>objectWillChange</code>，一个是@Published修饰的<code>$host</code>。在ModelYView中为这个<code>$host</code>添加一个订阅者，以及新增一个修改host属性的按钮。通过测试会发现，两个Publisher都能如期分发数据，前者会在任意属性变动的时候分发，后者只会在host属性发生变动的时候分发，这符合我们的预期。如果我们只是关心model发生变动，不关心具体变动的属性，那么这里的$host多少显得有些多余和重复，但如果我们要特殊的对该属性做处理，它就显得很合适了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelYView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        modifHostButton.addTarget(<span class="keyword">self</span>, action: #selector(modifHost), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">        addSubview(modifHostButton)</span><br><span class="line">        </span><br><span class="line">        modelY</span><br><span class="line">            .objectWillChange</span><br><span class="line">            .<span class="built_in">print</span>(<span class="string">"objectWillChange"</span>)</span><br><span class="line">            .sink &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.updateUI()</span><br><span class="line">            &#125;</span><br><span class="line">            .store(<span class="keyword">in</span>: &amp;subscriptions)</span><br><span class="line">        </span><br><span class="line">        modelY</span><br><span class="line">            .$host</span><br><span class="line">            .<span class="built_in">print</span>(<span class="string">"host"</span>)</span><br><span class="line">            .sink &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"modelY.host did change <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .store(<span class="keyword">in</span>: &amp;subscriptions)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">modifHost</span><span class="params">()</span></span> &#123;</span><br><span class="line">        modelY.host = <span class="string">"rocky"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，我们也不用过多的担心，一个模型中有n多个@Published修饰的属性会创建巨多的Publisher从而导致内存暴涨，这样的情况。在Combine中，如果一个Publisher不被订阅，那么它就不会被创建，从下面的内存分布中也可以看出来这个结论，所以无需担心模型中n多个的@Published。</p>
<img src="/2021/01/12/before-state-and-data-flow/publisher_count.png" title="publisher_count">
<p>使用了@Published标记了属性省去了很多分发侧的样板代码，但是还不够优雅，我们还需要在接收侧中去主动监听Publisher。回想一下前面提到的<code>Property Wrappers</code>，通过它可以统一的处理一些样板逻辑，而这里的为Publisher添加订阅-更新就是一个样板逻辑。</p>
<p>比如提供一个叫做<code>ObservedObject</code>的<code>Property Wrappers</code>来标记我们的modelY，从而就可以减少对Publisher的添加监听、更新等逻辑，这也是系统在swiftUI中提供的<code>ObservedObject</code>。</p>
<p>但是目前还遗留一个问题：实现model与view之间的双向绑定，这个就要涉及到swiftUI中的Binding、State等<code>Property Wrappers</code>。通过这些特性，SwiftUI消除了为了在屏幕上显示数据而需要复制数据的需求，能够将数据存储从UI中剥离出来，可以在模型的单个位置有效地管理数据，而且不会让应用的用户在屏幕上看到任何旧状态。</p>
<h2 id="DynamicMemberLookup">DynamicMemberLookup</h2><p>在OC中我们借助于runtime访问一个对象不存在的属性，经过一系列的查找、转发之后，系统会给我们一个崩溃。而在swift中作为一个安全的类型语言，我们编译都会失败，根本运行不起来。如果真的有需求要动态的访问对象的某些不存在的属性，我们需要使用swift4.2为我们提供的<code>@dynamicMemberLookup</code>，使用它标记的类型将拥有动态调用的特性，只需要实现一个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(dynamicMember member: <span class="type">Any</span>) -&gt; <span class="type">Any</span></span><br></pre></td></tr></table></figure>
<p>比如有一个UserData，使用@dynamicMemberLookup来标记它，并且实现<code>subscript(dynamicMember)</code>方法，根据动态的属性在json中获取对应的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@dynamicMemberLookup</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserData</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> json: [<span class="type">String</span>: <span class="type">Any</span>]?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span>(dynamicMember member: <span class="type">String</span>) -&gt; <span class="type">Any</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> json = json &#123;</span><br><span class="line">                <span class="keyword">return</span> json[member] <span class="keyword">as</span> <span class="type">Any</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> member</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            json?[member] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们可以编写如下的代码，并且也不会编译报错，这样就为UserData这个类型添加了动态访问的特性。当然了，我们还可以重载<code>subscript(dynamicMember)</code>方法，设置不同类型的返回值，这在编译器来看是允许的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userData = <span class="type">UserData</span>(json: [</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"rocky"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">28</span>,</span><br><span class="line">    <span class="string">"address"</span>: <span class="string">"China.shanghai"</span></span><br><span class="line">])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"name:<span class="subst">\(userData.name)</span>"</span>)<span class="comment">// name:Optional("rocky")</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"age:<span class="subst">\(userData.age)</span>"</span>)<span class="comment">// age:Optional(28)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"unknow:<span class="subst">\(userData.rank)</span>"</span>)<span class="comment">// unknow:nil</span></span><br><span class="line"></span><br><span class="line">userData.rank = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after set rank:<span class="subst">\(userData.rank)</span>"</span>)<span class="comment">// after set rank:Optional(99)</span></span><br></pre></td></tr></table></figure>
<p>通过@dynamicMemberLookup，我们可以为自定义的模型增加动态性，可以根据内置数据进行动态映射，还可以使用另一个类型来映射。在SE:0252这个提案中，增加了以KeyPath为参数的动态特性，突破了以String为访问对象的限制，这在以KVC的基础上实现动态性更加便捷，这个特性与PropertyWrapper结合可以发挥出很大的作用，将在下面示例中进行体现。</p>
<p>下面我们尝试根据已有的特性，实现swiftUI中的@State、@Binding。</p>
<p>首先，我们提供一个动态类（MyBinding），使得它可以处理以KeyPath为参数的动态属性，这里为了拓展我们使用<code>setter</code>、<code>getter</code>两个闭包来将设置属性以及获取属性与dynamicMemberLookup结合，这样我们就可以根据KeyPath进行链式的获取数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line">@dynamicMemberLookup</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBinding</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> getter: () -&gt; <span class="type">T</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> setter: (<span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">get</span>: @escaping () -&gt; <span class="type">T</span>, <span class="keyword">set</span>: @escaping (<span class="type">T</span>) -&gt; <span class="type">Void</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.getter = <span class="keyword">get</span></span><br><span class="line">        <span class="keyword">self</span>.setter = <span class="keyword">set</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> getter() &#125;</span><br><span class="line">        <span class="keyword">nonmutating</span> <span class="keyword">set</span> &#123; setter(newValue) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> projectedValue: <span class="type">MyBinding</span>&lt;<span class="type">T</span>&gt; &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">U</span>&gt;(dynamicMember keyPath: <span class="type">WritableKeyPath</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;) -&gt; <span class="type">MyBinding</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="type">MyBinding</span>&lt;<span class="type">U</span>&gt;(</span><br><span class="line">            <span class="keyword">get</span>: &#123; <span class="keyword">self</span>.wrappedValue[keyPath: keyPath] &#125;,</span><br><span class="line">            <span class="keyword">set</span>: &#123; <span class="keyword">self</span>.wrappedValue[keyPath: keyPath] = $<span class="number">0</span> &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时还使用@propertyWrapper来标记了MyBinding，通过上一小节我们知道，使用<code>@MyBinding</code>标记的属性在发生变化的时候，会调用MyBinding的<code>wrappedValue</code>这个计算属性，而这个计算属性是根据getter、setter来实现读写的，这两个block的实现是在初始化的时候确定的。</p>
<p>我们简单的测试一下它，分别使用Int以及具有数据层级的struct来。可以发现，使用@MyBinding标记的属性能够与外部的数据进行绑定，达到共用同一份数据的目的，也就是我们说的<code>双向绑定</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example1</span> </span>&#123;</span><br><span class="line">    @<span class="type">MyBinding</span>(<span class="keyword">get</span>: &#123; counter &#125;, <span class="keyword">set</span>: &#123; counter = $<span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">var</span> inner_counter: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 此刻，counter:10 inner_counter:10</span></span><br><span class="line">        inner_counter = <span class="number">11</span></span><br><span class="line">        <span class="comment">// 此刻，counter:11 inner_counter:11</span></span><br><span class="line">        counter = <span class="number">99</span></span><br><span class="line">        <span class="comment">// 此刻，counter:99 inner_counter:99</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Example1</span>().run()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> </span>&#123; <span class="keyword">var</span> color: <span class="type">String</span>, <span class="keyword">var</span> money: <span class="type">Int</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123; <span class="keyword">var</span> name: <span class="type">String</span>, <span class="keyword">var</span> car: <span class="type">Car</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> person = <span class="type">Person</span>(name: <span class="string">"rocky"</span>, car: <span class="type">Car</span>(color: <span class="string">"red"</span>, money: <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    @<span class="type">Binding</span>(<span class="keyword">get</span>: &#123; person &#125;, <span class="keyword">set</span>: &#123; person = $<span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">var</span> inner_person: <span class="type">Person</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 此刻，person和inner_person都为 Person(name:rocky, Car(color:red, money:100))</span></span><br><span class="line">      	person.name = <span class="string">"Y_rocky"</span></span><br><span class="line">        inner_person.car.money = <span class="number">200</span></span><br><span class="line">        inner_person.car.color = <span class="string">"orange"</span></span><br><span class="line">        <span class="comment">// 此刻，person和inner_person都为 Person(name:Y_rocky, Car(color:orange, money:200))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Example2</span>().run()</span><br></pre></td></tr></table></figure>
<p>但是，我们创建MyBinding的时候太过于麻烦，上面测试中绑定的本质是被标记的数据依赖于外部的数据变化，所以很容易想到前面的Property Wrapper。接着再创建一个MyState，并且将它的projectedValue返回为MyBinding，这样被MyState标记的数据在发生变化的时候就会和MyBinding标记的数据产生双向绑定。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyState</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> defaultValue: <span class="type">T</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.defaultValue = wrappedValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span>.defaultValue &#125;</span><br><span class="line">        <span class="comment">// ?</span></span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">self</span>.defaultValue = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">MyBinding</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MyBinding</span>(</span><br><span class="line">            <span class="keyword">get</span>: &#123; <span class="keyword">return</span> <span class="keyword">self</span>.defaultValue &#125;,</span><br><span class="line">            <span class="comment">// ?</span></span><br><span class="line">            <span class="keyword">set</span>: &#123; newValue <span class="keyword">in</span> <span class="keyword">self</span>.defaultValue = newValue &#125;<span class="comment">// ERROR:Cannot assign to property: 'self' is immutable</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们有了两个工具，接着将他们放入一个应用场景中：一个视图控制器（MyDetailViewController）中使用@MyState标记的Rectangle数据会在子视图（MyTopView）被修改，并且在视图控制器中也会修改它的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;  <span class="keyword">var</span> x, y: <span class="type">Double</span>  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> </span>&#123;  <span class="keyword">var</span> topLeft, topRight, bottomLeft, bottomRight: <span class="type">Point</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTopView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    @<span class="type">MyBinding</span> <span class="keyword">var</span> rectangle: <span class="type">Rectangle</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(rectangle: <span class="type">MyBinding</span>&lt;<span class="type">Rectangle</span>&gt;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rectangle.topLeft.x = <span class="number">101</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDetailViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyState</span> <span class="keyword">private</span> <span class="keyword">var</span> rectangle = <span class="type">Rectangle</span>()<span class="comment">// init Rectangle</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> topView: <span class="type">MyTopView</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        topView = <span class="type">MyTopView</span>(rectangle: $rectangle)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">oop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rectangle.topLeft.x = <span class="number">100</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不论是在视图控制器中修改数据，还是在子视图中修改数据，根据我们设计的MyBinding和MyState来看，最终会进入到<code>初始化MyBinding的setter回调</code>中，以及<code>MyState对wrappedValue的set方法</code>中。到这里，我们已经无法进行下去了，由于MyState是一个不可变类型的，我们会得到一个<code>&#39;self&#39; is immutable</code>的编译错误。</p>
<img src="/2021/01/12/before-state-and-data-flow/MyBinding_MyState.png" title="MyBinding_MyState">
<blockquote>
<p>我们知道<code>struct是值类型的</code>，这就意味着，在多个地方传递的时候数据会被复制，如果我们改变了其中一个值，也只是改变了这个副本，并不会改变原始值，甚至其他副本。虽然可以使用<code>mutating</code>、<code>var</code>将struct由不可变的（immutable）变为可变的，但是<code>值类型还是建议保持不可变</code>，这点在swiftUI中很重要。</p>
</blockquote>
<p>如果我们将MyState由Struct替换为Class，那么问题就可以解决了；或者在MyState内部使用一个Class的私有类（比如叫做Storage）来存储被wrap的数据，我们只在有疑问的两个地方修改这个Storage的value也可以解决编译错误。不过很显然，系统并不是按照第一种来做的，那么就有可能是根据第二种方案来做的，具体原理官方也没有文档说明，目前这些都只是猜测。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyState</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyState</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: <span class="type">Storage</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.storage = <span class="type">Storage</span>(value: wrappedValue)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span>.storage.value &#125;</span><br><span class="line">        <span class="keyword">nonmutating</span> <span class="keyword">set</span> &#123; <span class="keyword">self</span>.storage.value = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在前面一小节我们还遗留了一个问题，那就是我们需要显示的去订阅Publisher，并且让依赖数据的控件在订阅回调中更新数据。由于这两个方法的实现都是在MyState中，所以我们可以在这里将数据的变动通知给外部，比如使用前面提到的ObservableObject。奇幻的地方就在这里，系统在这一步做了一些我们不知道的处理，然后将这种处理转交给SwiftUI进行更新界面，这也是<code>func update()</code>一直未提及的原因。在UIKit的示例中，本质上还是由于我们的界面并不是以数据驱动的，界面和数据之间只是依赖的关系，因此数据变动之后需要手动的更新界面。</p>
<h3 id="What_is_the_next">What is the next</h3><p>以上作为引子讨论了如何使用<code>Property Wrappers</code>来统一的完成更新下发，使用<code>@Published</code>、<code>ObservableObject</code>来完成model与view之间的绑定，以及尝试重新实现<code>Binding</code>、<code>State</code>来探究<code>双向绑定</code>。并且在一步步的探索过程中发现，绑定效果并不是很理想，想要达到Vuex那样的双向绑定还有很多事情要做。</p>
<p>接下来我们会系统的学习swiftUI中的<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>、<code>@StateObject</code>、<code>@EnvironmentObject</code>等这些Property Wrappers，从他们的使用场景以及官方建议来探讨在如何项目中合理的使用这些技术。</p>
<h2 id="参考文章">参考文章</h2><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#projections" target="_blank" rel="noopener">SE:0258 Property Wrappers</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md" target="_blank" rel="noopener">SE:0195 dynamic-member-lookup</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md" target="_blank" rel="noopener">SE:0252 keypath-dynamic-member-lookup</a></li>
<li><a href="https://developer.apple.com/documentation/swiftui/state-and-data-flow" target="_blank" rel="noopener">State and Data Flow</a></li>
<li><a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a></li>
</ul>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/swiftUI/">swiftUI</a></div></article></div><div class="post-nav"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/2020/07/15/use-Responder-Chain-send-event/" class="next-post">基于Responder Chain的对象交互</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>