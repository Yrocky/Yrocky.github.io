<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">动手设计一个加载组件</h1><div class="post-info">3月 21日 2016</div><div class="post-entry"><p>好的动画效果会让用户将时间的概念忽略掉，会让人愿意去看动画的执行。观赏动画一方面能够抵消掉由于网络延迟或者视图处理缓慢照成的用户焦虑感，另一方面可以通过精美的动画效果吸引用户的眼球，提高用户留存。那么着手实现一个动画控件可以说是对基础数学计算的一个检验，从开发角度来说就是对动效的理解以及掌握程度的考验。<br><img src="/2016/03/21/create-a-loading-control/loading.gif" alt="loading.gif" title=""><br><a id="more"></a></p>
<p>这篇文章主要是解析通过使用基础的Core Animation知识实现如上图所示的动画效果，并且将这个动画效果封装成为一个可复用的组件，最后在这个组件的基础上为其添加交互特性以及实现更加全面的加载效果。</p>
<h2 id="解析动效原理">解析动效原理</h2><p>文章第一部分是要解析如何实现这样的一个动效。从一个动画映入眼帘就应该思考它是如何运作的，需要的知识有哪些，涉及的细节部分等等，在这之后通过自己对动效的想法去尝试着进行实现，对不足之处进行修改。</p>
<h6 id="首先分析动画实现效果">首先分析动画实现效果</h6><p>通过观察可以发现，有三个不同颜色的点，四个位置，并且三个点在这四个位置间进行有规律的移动。仅此而已！</p>
<h6 id="然后分析实现动画所需要得东西">然后分析实现动画所需要得东西</h6><p>在通过分析之后可以进行一个思考层面的演练，把需要的东西罗列出来。</p>
<ul>
<li>三个点可以使用<code>CALayer</code>来实现</li>
<li>四个位置需要通过每一个点的大小以及加载控件的尺寸进行确定</li>
<li>另外如果要是三个点有规律的移动，需要使用一个计时器进行控制位移的动画</li>
<li>还有要对每一个位置进行一下标记，方便点的位移，这里使用枚举</li>
</ul>
<h6 id="接下来进行具体的实现">接下来进行具体的实现</h6><p>由上面可以知道，四个位置的确定离不开三个点的大小，而三个点的大小如果写死的话也是可以的，但是这里通过与组件的尺寸进行一个耦合使用等比变化大小，从而四个点也可以跟随着组件的尺寸进行合理的改变，使动画实现起来能够更加的均匀。</p>
<p>先确立点的大小，点是一个<code>CALayer</code>进行了切割之后形成的一个圆点，所以这里这么设置点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGFloat dotRadius = width &gt; height ? width / <span class="number">13</span> : height / <span class="number">13</span>;</span><br><span class="line">...</span><br><span class="line">dot.masksToBounds = YES;</span><br><span class="line">dot.cornerRadius = dotRadius;</span><br><span class="line">dot.bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> * dotRadius, <span class="number">2</span> * dotRadius);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对于四个位置的确定需要进行简单不绕弯的数学计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_topPoint 	= CGRectMake(width/<span class="number">2</span> - dotRadius, 	height/<span class="number">4</span> - dotRadius, 	<span class="number">2</span>*dotRadius, <span class="number">2</span>*dotRadius);</span><br><span class="line">_rightPoint 	= CGRectMake(<span class="number">3</span>*width/<span class="number">4</span> - dotRadius, 	height/<span class="number">2</span> - dotRadius, 	<span class="number">2</span>*dotRadius, <span class="number">2</span>*dotRadius);</span><br><span class="line">_bottomPoint	= CGRectMake(width/<span class="number">2</span> - dotRadius, 	<span class="number">3</span>*height/<span class="number">4</span> - dotRadius, <span class="number">2</span>*dotRadius, <span class="number">2</span>*dotRadius);</span><br><span class="line">_leftPoint 	= CGRectMake(width/<span class="number">4</span> - dotRadius, 	height/<span class="number">2</span> - dotRadius, 	<span class="number">2</span>*dotRadius, <span class="number">2</span>*dotRadius);</span><br></pre></td></tr></table></figure>
<p>然后将三个点选择四个位置中的三个进行frame初始化，挑一个其中的点为例</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_firstDot = (&#123;</span><br><span class="line">    _firstDot = [CALayer layer]<span class="comment">;</span></span><br><span class="line">    _firstDot.frame = _topPoint<span class="comment">;</span></span><br><span class="line">    _firstDot.masksToBounds = YES<span class="comment">;</span></span><br><span class="line">    _firstDot.cornerRadius = dotRadius<span class="comment">;</span></span><br><span class="line">    _firstDot.bounds = CGRectMake(0, 0, 2 * dotRadius, 2 * dotRadius)<span class="comment">;</span></span><br><span class="line">    _firstDot<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>对于点和位置的确定到这里就算实现了，下面要做的就是使用计时器让点在四个位置间进行规律动画。通过观察可以发现三个点在同一个时间，只有两个点动，另外的一个点不发生位移，那么这里就可以随便挑两个点先开始位移，需要注意的是，其中必须有一个点要穿过组件的中心点，然后另一个点不穿过中心点并且会成为下一个不位移的点，具体的一个周期效果图如下，<br><img src="/2016/03/21/create-a-loading-control/cycle.png" alt="cycle.png" title=""></p>
<p>先确定计时器，通过计时器的循环方法进行位移动画的实现，对外提供一个API，被动的调用计时器</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_loading) &#123;</span><br><span class="line">        </span><br><span class="line">        _loading = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        _timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:ANIMATION_DURATION_SECS</span><br><span class="line">		                                          target:<span class="keyword">self</span></span><br><span class="line">		                                        selector:<span class="keyword">@selector</span>(animationNextStep)</span><br><span class="line">		                                        userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过效果图可以分析出来，所有的点状态一共有六种，但是使用一个五个选项的枚举就可以完成一个循环，枚举如下，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSInteger ,HLLActivityIndicatorStep)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HLLActivityIndicatorStepZero = <span class="number">0</span>,</span><br><span class="line">    HLLActivityIndicatorStepOne,</span><br><span class="line">    HLLActivityIndicatorStepTwo,</span><br><span class="line">    HLLActivityIndicatorStepThree,</span><br><span class="line">    HLLActivityIndicatorStepFour</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在计时器的<code>- animationNextStep</code>方法中要做的就是在不同的枚举类型下进行点的位移动画，然后在移动完成之后枚举类型递进一位，大致如下，</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>) animationNextStep&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (_stepNumber) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">HLLActivityIndicatorStepZero:</span></span><br><span class="line">        &#123;</span><br><span class="line">            [CATransaction begin];</span><br><span class="line">            [CATransaction <span class="string">setAnimationDuration:</span>ANIMATION_DURATION_SECS];</span><br><span class="line">            ...</span><br><span class="line">            [CATransaction commit];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">HLLActivityIndicatorStepOne:</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">HLLActivityIndicatorStepFour:</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            _stepNumber = HLLActivityIndicatorStepZero;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="label">        default:</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _stepNumber ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有开始就要有结束，也是一个对外的API，里面的操作是要停止计时器、将三个点归位为初始的三个位置，然后将标志位枚举置为0。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)stopLoading&#123;</span><br><span class="line">    </span><br><span class="line">    _loading = NO<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    [self.timer invalidate]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    _stepNumber = HLLActivityIndicatorStepZero<span class="comment">;</span></span><br><span class="line">    [CATransaction begin]<span class="comment">;</span></span><br><span class="line">    [CATransaction setAnimationDuration:ANIMATION_DURATION_SECS]<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">    [CATransaction commit]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现一个网络加载处理的控制器类">实现一个网络加载处理的控制器类</h2><p>上一部分仅仅是实现了一个简单的动画加载控件，可以单独的把他应用到项目中，也可以将他结合控制器很好的用于解决由于网络加载缓慢以及加载错误等等的友好显示。</p>
<p>一般来说一个网络请求从发出去到服务器响应请求并返回数据给客户端这一段时间是难以估计的，并且这段时间基本上UI界面是没有什么变化的，但是在另一个线程的网络方面，是有很大的变化的。对于用户体验来说一个可以用于提示用户网络请求加载的UI是在网络请求发送之后不可缺少的一部分，有的时候还可能出现网络超时的情况，并且网络请求有时候会有各种的300、400、500错误导致返回的不是客户端需要的数据，因此还需要能有很好的对错误响应的处理功能，基本的错误原因展示功能是必须的，其他的情况先不考虑。</p>
<p>结合需要一个网络等待的UI和能对错误信息进行操作这两个需求，下面做一个不是很好移植，但是很简单的网络加载控制器，姑且叫它 — <code>NetworkingLoadingController</code>。这是一个控制器，对于一个控制器要显示在另外一个正在展示的控制器上，除了<code>模态</code>、<code>导航</code>之外还可以使用<code>Segue</code>，其实是使用了UIKit中一个比较少用到的类 — <code>UIContainerView</code>。</p>
<img src="/2016/03/21/create-a-loading-control/containerView.png" alt="container" title="container">
<p>这个类可以在控制器中占位，并且通过Segue连接一个视图控制器，视图控制器可以显示在UIContainerView占的位置上。但是这个类只能够在StoryBoard中创建以及使用，这就照成了以后要移植这个加载控制器不会很方便，但是他的创建很简单。既然他是通过Segue来连接一个占位视图和控制器的，所以在主控制器中可以通过<code>-prepareForSegue:sender:</code>方法获得到占位的控制器。</p>
<p>我的做法是使用一个UIContainerView占位，连接这个<code>NetworkingLoadingController</code>，然后NetworkingLoadingController提供一套UI显示：网络加载、错误处理、响应结果显示等等，其中在主视图控制器中可以获取到NetworkingLoadingController，并且进行相应的UI展示，另外NetworkingLoadingController中的交互事件可以通过<code>代理模式</code>与主试图控制器之间传递。</p>
<h6 id="视图控制器间通信">视图控制器间通信</h6><p>对于不同之间的UI切换可以通过获取的NetworkingLoadingController进行主动的方法调用，使用代理-协议使两个视图控制器之间进行通信，首先要获得NetworkingLoadingController并且设置代理，具体的代理协议可以视情况而定，这里简单的设置一个，就是当出现请求超时的时候，NetworkingLoadingController提供一个重新尝试的点击操作，将这个操作传递给主视图控制器。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set protocol</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NetworkLoadingViewDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span>;</span><br><span class="line">-(<span class="keyword">void</span>) retryRequestButtonWasPressed:(NetworkLoadingViewController *)viewController;</span><br><span class="line"><span class="keyword">@end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get NetworkingLoadingController and set delegate</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([segue<span class="variable">.identifier</span> isEqualToString:<span class="string">@"networkLoadingSegue"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.networkLoadingController</span> = segue<span class="variable">.destinationViewController</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.networkLoadingController</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当NetworkingLoadingController的UI要响应一些点击事件的时候使用常规的代理方法就可以将事件传递给代理</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">retryRequest</span>:(id)<span class="tag">sender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="tag">if</span> (self.delegate &amp;&amp; [self.delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">retryRequestButtonWasPressed</span>:)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr_selector">[self.delegate retryRequestButtonWasPressed:self]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr_selector">[self showLoadingView]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于主动的进行UI切换，比如，在主视图控制器中的某一个操作要进行网络请求的时候，可以通过调用NetworkingLoadingController的方法，其中的<code>loadContainerView</code>就是UIContainerView。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.loadContainerView</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.networkLoadingController</span> showLoadingView];</span><br></pre></td></tr></table></figure>
<p>具体的<code>-showLoadingView</code>方法中的操作就是显示加载UI，隐藏错误处理以及其他无关UI。</p>
<h6 id="加载UI部分">加载UI部分</h6><p>加载部分的UI由上面的加载控件以及一个标签视图组成，在NetworkingLoadingController要显示加载UI的时候开始加载控件的动画，隐藏的时候停止动画，标签仅仅是一个显示“Loading…”。UI如下，</p>
<img src="/2016/03/21/create-a-loading-control/loadingUI.png" alt="loadingUI" title="loadingUI">
<h6 id="错误处理UI部分">错误处理UI部分</h6><p>对于错误处理部分，第一是要能够显示错误信息，第二是能够让用户面对错误进行下一步操作，比如超时请求的重试，</p>
<img src="/2016/03/21/create-a-loading-control/errorUI.png" alt="errorUI" title="errorUI">
<h6 id="展示响应UI部分">展示响应UI部分</h6><p>有的时候不仅仅需要有加载的UI和处理错误的UI，还需要将响应的结果进行一个展示，这时候大可以再添加一个视图用于展示相应的数据。</p>
<img src="/2016/03/21/create-a-loading-control/responseUI.png" alt="responseUI" title="responseUI">
<h3 id="NetworkingLoadingController的详细UI结构">NetworkingLoadingController的详细UI结构</h3><p>结合以上的UI展示可以看出来，通过显示隐藏不同的UI来进行响应不同的网络情况，那么NetworkingLoadingController的具体的UI结构如下，</p>
<img src="/2016/03/21/create-a-loading-control/NetworkingLoadingControllerUI.png" alt="NetworkingLoadingControllerUI" title="NetworkingLoadingControllerUI">
<p>以上的这些UI都是在NetworkingLoadingController的View上的，而NetworkingLoadingController又是根据UIContainerView占位显示的，所以在主视图控制器中添加UIContainerView的时候要将它添加在最后一个，也就是最前面，这样才能够覆盖全屏显示网络加载信息，当然也可以不覆盖全屏，但是一定要在最前面！！</p>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/组件/">组件</a></div></article></div><div class="post-nav"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/2016/04/03/tableView-select/" class="prev-post">iOS开发中的单选与多选</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/2016/02/29/UILocatioinedIndexCollection/" class="next-post">更加便捷的表视图索引----UILocalizedIndexedCollation</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>