<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>更加便捷的表视图索引----UILocalizedIndexedCollation | Rocky&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="通常使用UITableView来展示一些具有相同的数据，但是当屏幕中的数据比较多的时候，一个实际场景是通讯录列表，成千上百的通讯录信息，如果要查找比较靠后的通讯信息，就需要疯狂的滑动屏幕直到到达自己需要的区域。这不是一个很好的用户体验，应该说是一个很糟糕的用户体验，当然在通讯录信息比较少的时候他还不会体现出来，但是身为开发人员应该提前意识到这个问题的存在，并在开发阶段解决。">
<meta property="og:type" content="article">
<meta property="og:title" content="更加便捷的表视图索引----UILocalizedIndexedCollation">
<meta property="og:url" content="http://yoursite.com/2016/02/29/UILocatioinedIndexCollection/index.html">
<meta property="og:site_name" content="Rocky's blog">
<meta property="og:description" content="通常使用UITableView来展示一些具有相同的数据，但是当屏幕中的数据比较多的时候，一个实际场景是通讯录列表，成千上百的通讯录信息，如果要查找比较靠后的通讯信息，就需要疯狂的滑动屏幕直到到达自己需要的区域。这不是一个很好的用户体验，应该说是一个很糟糕的用户体验，当然在通讯录信息比较少的时候他还不会体现出来，但是身为开发人员应该提前意识到这个问题的存在，并在开发阶段解决。">
<meta property="og:image" content="http://yoursite.com/2016/02/29/UILocatioinedIndexCollection/locationIndexCollection.png">
<meta property="og:updated_time" content="2016-03-16T16:07:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="更加便捷的表视图索引----UILocalizedIndexedCollation">
<meta name="twitter:description" content="通常使用UITableView来展示一些具有相同的数据，但是当屏幕中的数据比较多的时候，一个实际场景是通讯录列表，成千上百的通讯录信息，如果要查找比较靠后的通讯信息，就需要疯狂的滑动屏幕直到到达自己需要的区域。这不是一个很好的用户体验，应该说是一个很糟糕的用户体验，当然在通讯录信息比较少的时候他还不会体现出来，但是身为开发人员应该提前意识到这个问题的存在，并在开发阶段解决。">
  
    <link rel="alternative" href="/atom.xml" title="Rocky&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      
        <h1 id="logo-image">
          <a href="/" id="logo-image-a">
            <img border="0" src="http://tp4.sinaimg.cn/2055300355/180/5701319722/2" />
          </a>
        </h1>
      
      <h1 id="logo-wrap">
        <p id="logo">Rocky&#39;s blog</>
      </h1>
    </div>
    <div id="header-inner" class="inner">
      
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>

    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-UILocatioinedIndexCollection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/29/UILocatioinedIndexCollection/" class="article-date">
  <time datetime="2016-02-29T12:32:00.000Z" itemprop="datePublished">2016-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      更加便捷的表视图索引----UILocalizedIndexedCollation
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通常使用UITableView来展示一些具有相同的数据，但是当屏幕中的数据比较多的时候，一个实际场景是通讯录列表，成千上百的通讯录信息，如果要查找比较靠后的通讯信息，就需要疯狂的滑动屏幕直到到达自己需要的区域。这不是一个很好的用户体验，应该说是一个很糟糕的用户体验，当然在通讯录信息比较少的时候他还不会体现出来，但是身为开发人员应该提前意识到这个问题的存在，并在开发阶段解决。</p>
<a id="more"></a>
<p>那么如何解决这个问题从而优化用户体验呢？以下是几个简单的解决方案：</p>
<ul>
<li>第一个，使用类似于QQ好友列表那样，将具有相同属性的数据归为一个Section，然后提供这个SectionHeaderView可以打开关闭。</li>
<li>第二个，为该UITableView提供一个UISearchBar在其头部，通过用户输入的关键字进行数据的筛选，具体可以看手机通讯录界面。</li>
<li>第三个，提供侧边栏<code>区域索引标题</code>，也就是纵向排列的字母，具体可以看手机通讯录界面。</li>
</ul>
<p>其他的解决办法可以是以上几种结合着使用，这里只针对于第三种方法进行一个扩展，也算是对UILocatioinedIndexCollection的一个学习。</p>
<h2 id="为什么使用UILocalizedIndexedCollation">为什么使用UILocalizedIndexedCollation</h2><p>当使用第三种方法的时候需要实现一个数据源方法：<code>-sectionIndexTitlesForTableView:</code>，另外一个方法可选<code>-tableView:sectionForSectionIndexTitle:atIndex:</code>。</p>
<p>可以自己动手去生成这个字母列表，这是一个比较正确且传统的办法，优点是可以按照实际的数据获得字母列表，缺点就是还要自己处理逻辑以及针对于不同的地区的字母列表可能还需要做本地化适配。</p>
<p>那能否找到一个智能的类，能够提供字母排序，并且还可以很方便的完成本地化操作？这时候就提现出来一个新的功能类，用来进行提供快速索引—<a href="https://developer.apple.com/library/prerelease/ios/documentation/iPhone/Reference/UILocalizedIndexedCollation_Class/index.html#//apple_ref/doc/uid/TP40008302" target="_blank" rel="external">UILocalizedIndexedCollation</a>，他是一个单例，通过<code>+currentCollection</code>就可以获得对象，他的作用是<strong>根据地区来生成与之对应的区域索引标题</strong>.</p>
<h2 id="初识UILocalizedIndexedCollation">初识UILocalizedIndexedCollation</h2><p>UILocationIndexCollection提供了两个数组属性用于获取<code>sectionIndexTitles</code>和<code>sectionTitles</code>，需要注意的是不同地区，sectioinIndexTitles是不同的，英文环境下就是比较常用的“A、B…Z 、#”，其他地区有所差别，具体可以看这个</p>
<img src="/2016/02/29/UILocatioinedIndexCollection/locationIndexCollection.png" alt=" UILocalizedIndexedCollation" title=" UILocalizedIndexedCollation">
<p>所以看到这里就应该发现一个问题，不论什么地区使用UILocationedIndexCollection返回的sectionTitles或者sectionIndexTitles都是全部的数据，也就是说是最大集合，但是实际情况中的数据信息有可能是该集合的子集，没有的数据一般是不会显示出来的，这也算是使用UILocatioinedIndexCollection的一个不智能的地方了吧。但是如果还是想使用UILocatioinedIndexCollection，但是数据又不全，那就需要再做一些操作了。</p>
<p>从UILocalizedIndexedCollation提供的方法中可以看出来，他和UITableViewDataSource中的某一些方法是完美结合的：</p>
<ul>
<li><strong>-tableView:titleForHeaderInSection:</strong></li>
<li><strong>-sectionTitles</strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回每一个对应Section的内容</span></span><br><span class="line"><span class="comment">// 如果使用UILocalizedIndexedCollation，可以使用`-sectionTitles`数组中的对象</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.collection</span> sectionTitles][section];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-sectionIndexTitlesForTableView:</strong></li>
<li><strong>-sectionIndexTitles</strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个区域索引标题的数组，用于在列表右边显示，例如字母序列 A...Z 和 #。注意，区域索引标题很短，通常不能多于两个 Unicode 字符。</span></span><br><span class="line"><span class="comment">// 如果使用UILocalizedIndexedCollation，可以使用`-sectionIndexTitles`方法返回索引数组</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)sectionIndexTitlesForTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.collection</span> sectionIndexTitles];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-tableView:sectionForSectionIndexTitle:atIndex:</strong></li>
<li><strong>-sectionForSectionIndexTitleAtIndex:</strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个NSInteger类型的值，当点击返回当用户触摸到某个索引标题时列表应该跳至的区域的索引，比如B-1</span></span><br><span class="line"><span class="comment">// 如果使用UILocalizedIndexedCollation，可以通过`-sectionForSectionIndexTitleAtIndex:`方法进行返回点击到侧边栏的字母要跳转到的Section区域</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>) tableView:(<span class="built_in">UITableView</span> *)tableView sectionForSectionIndexTitle:(<span class="built_in">NSString</span> *)title atIndex:(<span class="built_in">NSInteger</span>)index&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.collection</span> sectionForSectionIndexTitleAtIndex:index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于UILocatioinedIndexCollection中余下的两个方法：<strong>-sectionForObject: collationStringSelector:</strong>和<strong>-sortedArrayFromArray:collationStringSelector:</strong></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A selector that identifies a <span class="keyword">method</span> returning an identifying <span class="type">string</span> </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">object</span> that <span class="keyword">is</span> used <span class="keyword">in</span> collation. </span><br><span class="line"></span><br><span class="line"><span class="type">The</span> <span class="keyword">method</span> should take no arguments <span class="keyword">and</span> <span class="keyword">return</span> an <span class="type">NSString</span> <span class="keyword">object</span>.</span><br><span class="line"></span><br><span class="line"><span class="type">For</span> example, this could be a name property on the <span class="keyword">object</span>.</span><br></pre></td></tr></table></figure>
<p>看文档可以发现是用于排序的，两个方法的最后一个参数需要传递一个选择子，必须是<code>没有参数</code>，并且<code>返回值是NSString对象</code>的方法，因此这里可以使用该对象的一个字符串属性。</p>
<p>第一个是用于排列出对象属于哪一个Section，返回一个NSInteger数据，就是标明该对象属于哪一个Section中。</p>
<p>第二个是用于对某一个Section下的Rows(数组)按照选择子进行排序，返回的是完成排序的SortedRows(数组)。</p>
<h2 id="如何使用UILocalizedIndexedCollation">如何使用UILocalizedIndexedCollation</h2><p>当拿到了装有要展示的、未排序、未分区的对象数组(objectsArray)之后，如何结合UILocalizedIndexedCollation免去排序以及索引的添加呢？需要做的就是讲数据和UILocalizedIndexedCollation进行合理的结合，以便能够在UITableView中显示出来正确的数据，大致上有三步：</p>
<ul>
<li>第一步，获取到所有的Sections数组，这个是根据系统环境固定个数的一个数组，这也是使用UILocalizedIndexedCollation不好的地方</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> sectionTitlesCount = [[<span class="built_in">UILocalizedIndexedCollation</span> currentCollation] sectionTitles]<span class="variable">.count</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> * newSectionsArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  获得所有的sections数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; sectionTitlesCount; index ++) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> * rows = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    [newSectionsArray addObject:rows];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步，遍历对象数组(objectsArray)，由UILocalizedIndexedCollation决定每一个对象按照选择子应该属于哪一个Section，</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (id <span class="class"><span class="keyword">object</span> <span class="title">in</span> <span class="title">objectsArray</span>) &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得每个对象所在的section</span></span><br><span class="line">    <span class="type">NSInteger</span> sectionNumber = [[<span class="type">UILocalizedIndexedCollation</span> currentCollation] sectionForObject:<span class="class"><span class="keyword">object</span> </span><br><span class="line"></span>                                                                       collationStringSelector:<span class="annotation">@selector</span>(someProperty)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过setionNumber取出section数组</span></span><br><span class="line">    <span class="type">NSMutableArray</span> * rows = newSectionsArray[sectionNumber];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把属于该section的对象放入数组section数组中</span></span><br><span class="line">    [rows addObject:<span class="class"><span class="keyword">object</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步，对每一个Section分区下的对象进行排序，通过UILocalizedIndexedCollation来决定，省去了自己写排序逻辑</li>
</ul>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (NSInteger <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; sectionTitlesCount; <span class="keyword">index</span> ++) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原始的对应section下的数组</span></span><br><span class="line">    NSArray * rows = newSectionsArray[<span class="keyword">index</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  排过序之后的section下的数组</span></span><br><span class="line">    <span class="comment">// 注意这里如果tableView是可以编辑的，就需要使用mutable copy</span></span><br><span class="line">    NSArray * sortedRowsArray = [[UILocalizedIndexedCollation currentCollation] sortedArrayFromArray:rows </span><br><span class="line">                                                                             collationStringSelector:@selector(someProperty)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 替换掉原来的数组</span></span><br><span class="line">    [newSectionsArray replaceObjectAtIndex:<span class="keyword">index</span> withObject:sortedRowsArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做完这些之后会发现，UITableViewDataSource方法中的一些重要方法可以实现了，但是到目前为止使用UILocalizedIndexedCollation仅仅还能实现这一个：</p>
<p><strong>-numberOfSectionsInTableView:</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>) numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[[<span class="built_in">UILocalizedIndexedCollation</span> currentCollation] sectionTitles] count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<strong>-tableView:numberOfRowsInSection:</strong>和<strong>-tableView:cellForRowAtIndexPath:</strong>这两个重要的方法还是不能实现的，因为这需要知道更加具体的Section内部的数组信息，而不是仅仅使用UILocalizedIndexedCollation的<code>-sectionTitles</code>方法获得的SectionTitles，所以需要再引入一个变量，用来持有在三步操作中获得的<code>newSectionArray</code>—-sectionsArray，以便在别的地方使用。</p>
<p>在第三步之后添加一句</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self.sectionsArray </span>= newSectionsArray<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>现在可以实现那两个数据源方法了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>) tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> * rows = <span class="keyword">self</span><span class="variable">.sectionsArray</span>[section];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rows<span class="variable">.count</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *) tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UITableViewCell</span> * cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cellIdentifier"</span> forIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> * rows = <span class="keyword">self</span><span class="variable">.sectionsArray</span>[indexPath<span class="variable">.section</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> object = rows[indexPath<span class="variable">.row</span>];</span><br><span class="line">    </span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,object<span class="variable">.someProperty</span> ? : <span class="string">@" "</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上UILocalizedIndexedCollation的使用就这样了，说的比较繁琐，具体可以参考下面的文章或者例子。</p>
<h2 id="将UILocalizedIndexedCollation封装进数据源类中">将UILocalizedIndexedCollation封装进数据源类中</h2><p>使用UILocalizedIndexedCollation进行对象的排序，并且为以后方便使用，抽出来一个数据源类，里面已经通过UILocalizedIndexedCollation实现了元素排序的操作，同时使用Block分离了UITableViewCell的显示设置。</p>
<p>由于这是单独抽取的数据源对象，难免以后在其他的工程也会使用到或者同一个工程有多种的数据源对象。为方便移植，还写了一个协议进行约束数据源的一些标准配置，<code>HLLSortProtocol</code>协议如下，</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@protocol HLLSortProtocol &lt;NSObject&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">@required</span></span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  Use for UITabbarButtonItem</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (readonly) NSString *name;</span></span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  Use for UIViewController's title</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (readonly) NSString *navigationBarName;</span></span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  Decision what style of UITableView</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (readonly) UITableViewStyle tableViewStyle;</span></span><br><span class="line"></span><br><span class="line">- (id)elementForIndexPath:(NSIndexPath <span class="keyword">*</span>)indexPath;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  The Identifier for dequeue reusable Cell</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  <span class="comment">@return Identifier</span></span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">- (NSString <span class="keyword">*</span>)cellIdentifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">@optional</span></span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  UITableView register Cell with CellClass</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  <span class="comment">@return The class of UITableViewCell</span></span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">- (Class) cellClass;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  UITableView register Cell with Nib</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  <span class="comment">@return The nib of UITableViewCell</span></span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">- (UINib <span class="keyword">*</span>) nib;</span><br><span class="line"></span><br><span class="line">- (NSString <span class="keyword">*</span>)tableView:(UITableView <span class="keyword">*</span>)tableView titleForHeaderInSection:(NSInteger)section;</span><br><span class="line"></span><br><span class="line"><span class="comment">@end</span></span><br></pre></td></tr></table></figure>
<p>分离出来的数据源对象只需要实现相应的协议方法就可以了。</p>
<p>对于这个使用了UILocalizedIndexedCollation进行实现数据源方法的类，使用便利初始化方法进行原始数据的获取以及设置需要的排序规则，并且将UITableViewCell的显示使用Block进行分离实现</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(id)</span>initWithDatas:<span class="params">(<span class="variable">NSArray</span> *)</span>datas sortElementByPropertySelector:<span class="params">(<span class="variable">SEL</span>)</span>selector</span><br><span class="line">                                                configureCellBlock:<span class="params">(<span class="variable">TableViewCellConfigureBlock</span>)</span>aConfigureCellBlock;</span></span><br></pre></td></tr></table></figure>
<p>另外关于如果Section下没有元素的时候sectionHeaderView还是会显示字母的bug，只需要简单的一个判断就可以解决：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *) tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> * rows = <span class="keyword">self</span><span class="variable">.sectioinsArray</span>[section];</span><br><span class="line">    <span class="keyword">if</span> (rows<span class="variable">.count</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.collection</span> sectionTitles][section];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Yrocky/HLLContactsDemo/tree/master/HLLContactsDemo/DataSource" target="_blank" rel="external">具体的类实现细节看这里</a></p>
<h2 id="参考文章：">参考文章：</h2><ul>
<li><a href="http://nshipster.cn/uilocalizedindexedcollation/" target="_blank" rel="external">NSHipster</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/iPhone/Reference/UILocalizedIndexedCollation_Class/index.html#//apple_ref/occ/instm/UILocalizedIndexedCollation" target="_blank" rel="external">Apple Developer Library</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/samplecode/TableViewSuite/Listings/3_SimpleIndexedTableView_SimpleIndexedTableView_APLViewController_m.html#//apple_ref/doc/uid/DTS40007318-3_SimpleIndexedTableView_SimpleIndexedTableView_APLViewController_m-DontLinkElementID_22" target="_blank" rel="external">Sample Code:3_SimpleIndexedTableView</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
          <p class="article-more-link">
            <a href="/2016/02/29/UILocatioinedIndexCollection/#more">阅读全文 -&gt;</a>
          </p>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UITableView/">UITableView</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI学习/">UI学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  

  
    <a href="/2016/02/26/teach-Girl-How-To-Use-UITableView-With-A-Series-Demo/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">通过Sample Code逐步学习使用UITableView</div>
    </a>
  
  
</nav>

  
</article>
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/UITableView/" style="font-size: 12.5px;">UITableView</a> <a href="/tags/UI学习/" style="font-size: 12.5px;">UI学习</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/iOS9/" style="font-size: 10px;">iOS9</a> <a href="/tags/iOS开发/" style="font-size: 12.5px;">iOS开发</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/runtime/" style="font-size: 17.5px;">runtime</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/文档/" style="font-size: 10px;">文档</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  

  <div class="outer">
    
    <div id="footer-info" class="inner">
      All content copyright &copy; 2016 <a href="/"> Rocky </a> • All rights reserved.<br>
      使用 <a href="http://hexo.io/" target="_blank">Hexo</a>驱动 • 自定制主题
    </div>

  </div>

</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>