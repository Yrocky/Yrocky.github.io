<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">换个思路，让编程更加有意思</h1><div class="post-info">5月 15日 2017</div><div class="post-entry"><p>记录一些自己平常使用的另类编程方法，给繁复枯燥的代码平添一些乐趣。主要是从一些实际使用场景出发，探讨如何『偷懒』，让时间不那么浪费在重复修改代码上，即使修改也要让修改代码没那么麻烦。</p>
<a id="more"></a>
<h2 id="1-关于ActionSheet点击响应不同事件的一个使用场景">1.关于ActionSheet点击响应不同事件的一个使用场景</h2><p>比较常用的一个场景是一个界面中，我们需要弹出来一个ActionSheet，里面有n多个选项可供用户来选择。从产品设计的角度来说，对应的n种操作就是一个可怕的定时炸弹，不确定产品是不是会对这n种选项进行一个任性的排列；而从写代码的角度来说，对于这n种操作，写一个if-else或者switch-case是一个正确的选择，但是写下来你就会发现：冗余。再加上有可能会有排序的改动，那更加是毁灭性的代码。</p>
<p>对于这种类型的地方，没有必要花费太多精力来书写以及维护代码，需要的是简洁且易维护。</p>
<p>可以考虑使用数组将分支的操作进行存储，然后在点击选择时就可以直观的进行其对应的操作。可惜在Objective-C中，选择子<code>@selector</code>既不是基础数据类型也不是对象，是不能够使用数组存储的，那么就只能使用C数组来存储了，写出来大概是这个样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex &#123;&#10;&#10;&#160;&#160;&#160; SEL selectors[] = &#123;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; @selector(insertRow),&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; @selector(insertSection),&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; @selector(deleteSection)&#10;&#160;&#160;&#160; &#125;;&#10;&#10;&#160;&#160;&#160; if (buttonIndex &#60; sizeof(selectors) / sizeof(SEL)) &#123;&#10;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; void(*imp)(id, SEL) = (typeof(imp))[self methodForSelector:selectors[buttonIndex]];&#10;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; imp(self, selectors[buttonIndex]);&#10;&#160;&#160;&#160; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这样还是会带来两个问题，第一个是UIActionSheet的实现和方法是分开写的，第二个是即使这样还是需要维护两个数组，没有达到易维护的目的，但是好赖也比以前简单了许多。</p>
<p>第一个问题可以使用最新的<code>UIAlertController</code>的block来解决，但是这无疑又是一个问题，要写好多样板代码，这时候就需要对UIAlertController进行一下封装，使其使用起来更加简洁。</p>
<h2 id="2-对系统的UIAlertController进行封装">2.对系统的UIAlertController进行封装</h2><p>在iOS8.0之后系统就不推荐使用UIAlertView以及UIActionSheet，而使用了一个UIAlertController来替换他们两个。这样的做法对于混乱的视图展示层级来说确实是一个福音，并且可以使用block的方式来在一处处理对应的事件。但是，对于新的UIAlertController来说，要写好多的样板代码，一般来说，排版也不是很好看。</p>
<p>基于减少劳动力以及优化使用方式的目的，对系统的UIAlertController进行一层简单的封装。思路是使用协议的方式来约定是要显示的Alert以及ActionSheet类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@protocol HLLAlertActionSheetProtocol &#60;NSObject&#62;&#10;@optional&#10;#pragma mark - config&#10;&#10;- (id&#60;HLLAlertActionSheetProtocol&#62;) title:(NSString *)titile;&#10;- (id&#60;HLLAlertActionSheetProtocol&#62;) message:(NSString *)message;&#10;...&#10;@end</span><br></pre></td></tr></table></figure>
<p>使用一个<code>HLLAlertActionSheet</code>类来生成对应的alert或者actionSheet类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface HLLAlertActionSheet : NSObject&#10;+ (id&#60;HLLAlertActionSheetProtocol&#62;) alert;&#10;+ (id&#60;HLLAlertActionSheetProtocol&#62;) actionSheet;&#10;@end&#10;&#10;@implementation HLLAlertActionSheet&#10;#pragma mark - config&#10;+ (id&#60;HLLAlertActionSheetProtocol&#62;) alert&#123;    &#10;    return [HLLAlert alert];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>而对于alert以及actionSheet类来说，内部使用一个私有类来存储通过实现协议传入的设置，然后在<code>showIn:</code>方法中对UIalertContrller进行初始化、设置以及显示。一个alert类的部分内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface HLLAlert : NSObject&#60;HLLAlertActionSheetProtocol&#62;&#10;&#10;@property (nonatomic ,strong) HLLAlertActionSheetModel * aModel;&#10;#pragma mark - config&#10;+ (HLLAlert *) alert;&#10;@end</span><br></pre></td></tr></table></figure>
<p>其中实现协议方法时候把当前实例对象也返回出去：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (HLLAlert *) title:(NSString *)titile&#123;&#10;    &#10;    self.aModel.title = titile;&#10;    return self;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这样在使用的时候可以这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[[[[[HLLAlertActionSheet alert]&#10;          title:@&#34;&#20030;&#25253;&#36825;&#20010;&#20154;&#34;]&#10;         message:@&#34;&#30830;&#23450;&#20030;&#25253;&#24403;&#21069;&#20027;&#25773;&#30452;&#25773;&#30340;&#20869;&#23481;&#36829;&#35268;&#34;]&#10;        buttons:@[@&#34;&#21462;&#28040;&#34;,@&#34;&#20030;&#25253;&#34;]] style:UIAlertActionStyleCancel index:0]&#10;      showIn:self] fetchClick:^(NSInteger index) &#123;&#10;        &#10;        if (index = 1) &#123;// &#20030;&#25253;&#10;        &#125;&#10;    &#125;];</span><br></pre></td></tr></table></figure>
<p>对于传入的用于可选操作的内容，可以使用数组也可以使用类似于UIAlertView初始化的时候不定个数的字符串类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/** Default handle button type is `UIAlertActionStyleDefault`. */&#10;- (id&#60;HLLAlertActionSheetProtocol&#62;) buttons:(NSArray *)buttons;&#10;/** Explain some as above .&#36825;&#20010;&#37319;&#29992;&#22810;&#23383;&#31526;&#20018;&#30340;&#26041;&#24335;&#20256;&#36882;buttons&#65292;&#20197;&#24212;&#23545;button-fetch&#19981;&#23545;&#24212;&#30340;&#38382;&#39064;*/&#10;- (id&#60;HLLAlertActionSheetProtocol&#62;) buttonTitles:(NSString *)buttonTitles, ... NS_REQUIRES_NIL_TERMINATION;</span><br></pre></td></tr></table></figure>
<p>目前，没有做可以添加UITextField的封装，后续有时间再做。</p>
<h2 id="3-关于一个变量的实例化方式">3.关于一个变量的实例化方式</h2><p>其实这是<strong>小括号内联符合表达式</strong>写法–<code>A compound statement enclosed in parentheses.</code></p>
<p>想象一下，在对一个类的对象变量进行实例化的时候，往往需要写大量的关于这个对象变量的设置属性代码。</p>
<p>这种做法的最大的意义是将代码整理分块，将同一个逻辑的代码抱在一起；同时对于一个不需要复用的小段逻辑，免去了重量级函数的调用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.loginButton = (&#123;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];&#10;&#160; &#160; &#160; &#160; ...&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; button;&#10;&#160;&#160;&#160; &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="4-使用位域进行代理方法实现与否的判断">4.使用位域进行代理方法实现与否的判断</h2><p>在使用代理的时候需要判断代理代理是否实现了协议方法，一般的方法就是使用if-else进行书写，但是这样的切砖代码比较枯燥，也没有一点儿技术性可言，所以按照EOC中的方法可以使用以下方法进行书写，</p>
<p>使用结构体进行位的标记位：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface KKGestureLockView ()&#123;&#10;&#160;&#160;&#160; struct &#123;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unsigned int didBeginWithPasscode :1;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unsigned int didEndWithPasscode : 1;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unsigned int didCanceled : 1;&#10;&#160;&#160;&#160; &#125; _delegateFlags;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在设置代理的时候进行判断代理是否实现了相关协议方法，然后设置标记位：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(id&#60;KKGestureLockViewDelegate&#62;)delegate&#123;&#10;&#10;&#160;&#160;&#160; _delegate = delegate;&#160;&#10;&#10;&#160;&#160;&#160; _delegateFlags.didBeginWithPasscode = [delegate respondsToSelector:@selector(gestureLockView:didBeginWithPasscode:)];&#10;&#160;&#160;&#160; _delegateFlags.didEndWithPasscode = &#12290;&#12290;&#12290;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用标记位判断是否实现协议方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (_delegateFlags.didBeginWithPasscode) &#123;&#10;&#10;&#160;&#160;&#160;&#160;&#160;[self.delegate gestureLockView:self didBeginWithPasscode:[NSString stringWithFormat:@&#34;%zd&#34;,touchedButton.tag]];&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-改进属性字符串">5.改进属性字符串</h2><p>在使用属性字符串的时候，不论生成还是对已知字符串进行某些字段设置属性，都是一件很麻烦的事情，要编写大段的样板代码是在浪费时间。</p>
<p>改进生成属性字符串的方式，简单需求比如一个个的拼接：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// black 16&#10;+ (instancetype) builder;&#10;// &#123; NS...AttributeName : (id)value&#125;&#10;+ (instancetype) builderWithDefaultStyle:(NSDictionary *)defaultStyle;&#10;&#10;- (HLLAttributedBuilder *) appendString:(NSString *)string;&#10;- (HLLAttributedBuilder *(^)(NSString *str)) appendString;&#10;&#10;- (HLLAttributedBuilder *) appendString:(NSString *)string forStyle:(NSDictionary *)style;&#10;- (HLLAttributedBuilder *(^)(NSString *str ,NSDictionary *style)) appendStringAndStyle;</span><br></pre></td></tr></table></figure>
<p>更常见的需求比如，查找特定的字符串然后进行属性设置，一种情形是，已有一个字符串，需要对其中的某一些字符串进行属性字符串设置，支持精确匹配以及正则表达式匹配：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype) builderWithString:(NSString *)originalString;&#10;+ (instancetype) builderWithString:(NSString *)originalString defaultStyle:(NSDictionary *)defaultStyle;&#10;&#10;- (HLLAttributedBuilder *) configString:(NSString *)string forStyle:(NSDictionary *)style;&#10;- (HLLAttributedBuilder *(^)(NSString *str ,NSDictionary *style)) configStringAndStyle;</span><br></pre></td></tr></table></figure>
<p>根据上面设置的属性然后调用<code>- (NSAttributedString *) attributedString;</code>方法就可以生成对应的属性字符串。</p>
<p>使用例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString * display = @&#34;hello = nihao = Hello = &#20320;&#22909; = nihao&#34;;&#10;attachment &#26159;NSTextAttachment&#31867;&#30340;&#23454;&#20363;&#10;[[[[[[[HLLAttributedBuilder builderWithString:display]&#10;                      configString:@&#34;hello&#34; forStyle:@&#123;NSUnderlineColorAttributeName:[UIColor redColor],&#10;                                                       NSUnderlineStyleAttributeName:@1,&#10;                                                       NSForegroundColorAttributeName:[UIColor orangeColor]&#125;]&#10;                     configString:@&#34;nihao&#34; forStyle:@&#123;NSStrokeColorAttributeName:[UIColor redColor],&#10;                                                      NSStrokeWidthAttributeName:@1&#125;]&#10;                    configString:@&#34;H&#34; forStyle:@&#123;NSBackgroundColorAttributeName:[UIColor greenColor]&#125;]&#10;                   appendAttachment:attachment]&#10;                  appendString:@&#34;&#23043;&#22823;&#21916;&#34;]&#10;                 attributedString];</span><br></pre></td></tr></table></figure>
<p>内部主要是使用私有类来记录每次的属性设置，用<strong>attributedString</strong>属性来记录，然后使用数组来保存这个私有实例。对于<code>-append...</code>方式，每次将记录的对象放入数组，而对于<code>-configString...</code>方式，则是数组中一直只有一个对象。</p>
<h2 id="6-简化NSUserDefaults的使用">6.简化NSUserDefaults的使用</h2><p>NSUserDefaults一般用来保存一些简单的数据到本地，但是写起来会写很多的样板代码，没有什么技术含量，这里将NSUserDefaults添加一个分类，简化他的使用。</p>
<p>结合宏和block的特性，可以很优雅的使用点语法调用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MM_UserDefaults [NSUserDefaults standardUserDefaults]&#10;&#10;@interface NSUserDefaults (MM_Tools)&#10;&#10;- (NSUserDefaults *(^)(NSString *key,BOOL value))mm_addBool;&#10;- (BOOL(^)(NSString *))mm_boolValue;&#10;...&#10;- (NSUserDefaults *(^)(NSString *key,id value))mm_addObject;&#10;- (id(^)(NSString *))mm_objectValue;&#10;@end</span><br></pre></td></tr></table></figure>
<p>对应的实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSUserDefaults *(^)(NSString *,BOOL))mm_addBool&#123;&#10;    return ^NSUserDefaults *(NSString *key,BOOL value)&#123;&#10;        return self.mm_addObject(key,@(value));&#10;    &#125;;&#10;&#125;&#10;- (BOOL(^)(NSString *))mm_boolValue&#123;&#10;    &#10;    return ^BOOL(NSString *key)&#123;&#10;        return [self.mm_objectValue(key) boolValue];&#10;    &#125;;&#10;&#125;&#10;...&#10;- (NSUserDefaults *(^)(NSString *,id))mm_addObject&#123;&#10;    return ^NSUserDefaults *(NSString *key,id value)&#123;&#10;        [self setValue:value forKey:key];&#10;        [self synchronize];&#10;        return self;&#10;    &#125;;&#10;&#125;&#10;- (id(^)(NSString *))mm_objectValue&#123;&#10;    return ^id(NSString *key)&#123;&#10;        return [self valueForKey:key];&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候可以这样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MM_UserDefaults.mm_addBool(@&#34;some_bool_key&#34;,YES);&#10;MM_UserDefaults.mm_boolValue(@&#34;some_bool_key&#34;);</span><br></pre></td></tr></table></figure>
<h2 id="7-优雅的为分类添加属性">7.优雅的为分类添加属性</h2><p>难保会遇到要在某一个分类中添加好多的属性，需要结合runtime实现，但是需要写好多的重复代码，对于这些重复代码，使用宏来统一编写是一个很好的方法，不仅可以减少样板代码，还可以提高编译效率。</p>
<p>借由下面文章中的方法，实现为一个单例添加一些属性，结合上面的<code>MM_UserDefaults</code>对这些属性进行本地存储</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface MM_Manager (UserDefaults)&#10;&#10;mm_property_basicDataType(BOOL, openDebugerToggle&#10;...&#10;@end&#10;&#10;@implementation MM_Manager (UserDefaults)&#10;                          &#10;mm_def_property_basicDataType(BOOL, openDebugerToggle)&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>宏里面有两个对当前类的方法需要添加</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation MM_Manager (MM_associated)&#10;- (id)mm_getAssociatedObjectForKey:(const char *)key&#10;&#123;&#10;    const char * propName = key;&#10;    NSString * key_ = [NSString stringWithUTF8String:propName];&#10;    return MM_UserDefaults.mm_objectValue(key_);&#10;&#125;&#10;&#10;- (id)mm_setAssignAssociatedObject:(id)obj forKey:(const char *)key;&#10;&#123;&#10;    const char * propName = key;&#10;    NSString * key_ = [NSString stringWithUTF8String:propName];&#10;    id oldValue = MM_UserDefaults.mm_objectValue(key_);&#10;    MM_UserDefaults.mm_addObject(key_ ,obj);&#10;    NSLog(@&#34;userdefault:%@ for key:%@&#34;,obj,key_);&#10;    return oldValue;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>要了解如何使用宏，参考下面的文章</p>
<p><a href="http://blog.csdn.net/uxyheaven/article/details/46789065" target="_blank" rel="external">为分类添加试用宏添加属性</a></p>
<p><a href="http://www.jianshu.com/p/4c5613e256c8" target="_blank" rel="external">对ReactiveCocoa中宏的解释</a></p>
<p>Continue update …</p>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/学习/">学习</a></div></article></div><div class="post-nav"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/2017/08/05/sketch/" class="prev-post">使用Sketch进行设计学习</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/2016/12/11/one-function/" class="next-post">一个bug了解JS的核心知识点</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>