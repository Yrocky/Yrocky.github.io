<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">微信，让生活更美好 	 插件，让微信更方便</h1><div class="post-info">9月 11日 2017</div><div class="post-entry"><img src="/2017/09/11/hook-wechat/wechat_title.png" alt="title" title="title">
<p>不得不说，微信现在已经成为了生活中至关重要的一个工具。在使用的时候难免会想要一些个性化的功能，但是这些功能原版app内没有提供，那么就要靠自己动手了。由于iOSOpenDev不再更新引起的很多不便和搞事情前配置各种麻烦的命令让我都快放弃逆向了，恰巧前段时间看到<a href="http://iosre.com/t/topic/8696" target="_blank" rel="external">逆向社区</a>中的大大们在iOSOpenDev基础上整出了个更加好用的<a href="https://github.com/AloneMonkey/MonkeyDev.git" target="_blank" rel="external">MonkeyDev</a>，这个新的Dev让我又有了玩一把的心思。</p>
<p>使用MonkeyDev将以前的一些tweak放进去编译之后可以完美的跑在手机上了，现在逆向真的是有点傻瓜操作了，只需要关心如何将自己的想法hook出来，其余的繁复操作都交给Dev就好了。那好了，这次就好好体验一下MonkeyDev写一个微信助手的tweak，hook的思路会一步一步的列出来，代码基本不会贴出来，功能都是一些有实际需求但不知道可不可以实现的😜，不过80%在探索后都可以实现。</p>
<p>涉及到的功能包括但不会详细探究的：各种姿势抢红包、防止消息撤回、修改微信步数、群聊黑名单，因为这些功能都已经有很详细的教程讲解了，并且如果微信不改版，基本的hook思路是不会变的。虽然不会涉及到这些，但是也会将前人的思路整理列出来，以供查阅学习。另外针对于修改微信步数，我做了一个更加有趣的可玩功能，虽然是改步数，但是也要改的不那么明显。</p>
<p>here we go.</p>
<a id="more"></a>
<blockquote>
<p>以下功能都是在微信 6.5.16 版本下进行实现的</p>
</blockquote>
<h3 id="1-自动抢红包">1.自动抢红包</h3><p>思路大致为：hook收到红包的消息—&gt;进行红包解析—&gt;模拟执行抢的操作</p>
<p><a href="http://www.jianshu.com/p/189afbe3b429" target="_blank" rel="external">简书：一步步实现微信抢红包(非越狱)</a></p>
<p><a href="http://www.jianshu.com/p/677287a002be" target="_blank" rel="external">简书：微信红包实现原理</a></p>
<p><a href="https://github.com/buginux/WeChatRedEnvelop" target="_blank" rel="external">Github：Tweak源码</a></p>
<h3 id="2-防止消息撤回">2.防止消息撤回</h3><p>思路为：hook收到【撤回消息】的消息，不执行删除消息的操作，然后添加一个本地消息提示阻止了一条消息撤回。</p>
<p><a href="http://www.jianshu.com/p/7f65287a2e7a" target="_blank" rel="external">简书：Mac版微信防消息撤回  文章中有github地址</a></p>
<h3 id="3-群聊黑名单">3.群聊黑名单</h3><p>大致思路为：使用一个数组记录选择的黑名单到本地，hook获取消息的方法，如果是群聊消息且在数组中，就直接返回。</p>
<p><a href="https://github.com/buginux/WeChatRedEnvelop" target="_blank" rel="external">Github：Tweak源码</a></p>
<h3 id="4-花样修改微信步数">4.花样修改微信步数</h3><p>所有的修改微信步数的操作都是在获取在微信步数的时候hook，然后展示想要的数字。</p>
<p>对比这种太过痕迹化的改步数，在修改步数的时候增加一些可玩性的操作，让修改步数不那么明显。除了基础的固定步数，主要的玩法有两个：与『第一名』、『最后一名』、『任意一名』多/少n步；选择排行榜中的某一个人比他多/少n步。这些都是逻辑的处理，没什么可说的，看官也可以按照自己的想法编写一套逻辑来修改步数。</p>
<p>主要的难点在于获取加入微信运动排行榜的所有用户供选择，这个既然微信运动排行榜中有，那么就可以获取到。</p>
<p><strong>获取微信运动好友列表</strong>：在排行榜中获取好友列表的时候是使用的主动请求，具体的如何请求都放在了<strong>DeviceRankSnsMgr</strong>类里面，所以可以使用这个类进行模拟获取微信运动好友列表。请求排行版是通过这个类的<code>- (void)getUserRankListCount:(id)arg1 chanpionUsername:(id)arg2 brandUserName:(id)arg3</code>方法发出的，对于这个请求的响应是<code>- (void)handleRankGetUserRankLikeResponse:(ProtobufCGIWrap *)arg1</code>回调，其中<strong>ProtobufCGIWrap</strong>的有用信息如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">ProtobufCGIWrap </span>: NSObject </span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) GetUserRankLikeCountResponse *m_pbResponse; <span class="comment">// @synthesize m_pbResponse;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) GetUserRankLikeCountRequest *m_pbRequest; <span class="comment">// @synthesize m_pbRequest;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int m_uiCgi; <span class="comment">// @synthesize m_uiCgi;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>很明显，<code>m_pbResponse</code>和<code>m_pbRequest</code>分别指代的响应和请求，这两个属性对应的类如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">GetUserRankLikeCountRequest </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *appusername; <span class="comment">// @dynamic appusername;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *championname; <span class="comment">// @dynamic championname;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *rankid; <span class="comment">// @dynamic rankid;</span></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">likeItem </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int likecount; <span class="comment">// @dynamic likecount;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int likestate; <span class="comment">// @dynamic likestate;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int ranknum; <span class="comment">// @dynamic ranknum;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int score; <span class="comment">// @dynamic score;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *username; <span class="comment">// @dynamic username;</span></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">GetUserRankLikeCountResponse </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSMutableArray *follows; <span class="comment">// 关注的好友排行信息 &lt;Follow *&gt;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSMutableArray &lt;likeItem *&gt;*friendlikelist; <span class="comment">// @dynamic friendlikelist;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSMutableArray *likeuserlist; <span class="comment">// @dynamic likeuserlist;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *rankid; <span class="comment">// @dynamic rankid;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>到此已经知道如何进行请求，以及获取到什么样的数据。接着hopper<strong>DeviceRankSnsMgr</strong>的发送请求函数可以大致理出来微信发送请求的方式：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="atom">void</span>)<span class="atom">getUserRankListCount</span>:(<span class="atom">id</span>)<span class="atom">arg1</span> <span class="atom">chanpionUsername</span>:(<span class="atom">id</span>)<span class="atom">arg2</span> <span class="atom">brandUserName</span>:(<span class="atom">id</span>)<span class="atom">arg3</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="name">GetUserRankLikeCountRequest</span> * <span class="atom">request</span> = [[<span class="name">GetUserRankLikeCountRequest</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">    [<span class="atom">request</span> <span class="atom">setRankid</span>:@<span class="string">"latestRank"</span>];</span><br><span class="line">    [<span class="atom">request</span> <span class="atom">setAppusername</span>:@<span class="string">""</span>];</span><br><span class="line">    [<span class="atom">request</span> <span class="atom">setChampionname</span>:@<span class="string">""</span>];</span><br><span class="line"></span><br><span class="line">    <span class="name">ProtobufCGIWrap</span> * <span class="atom">cgiWrap</span> = [[<span class="name">ProtobufCGIWrap</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">    [<span class="atom">cgiWrap</span> <span class="atom">setM_pbRequest</span>:<span class="atom">request</span>];</span><br><span class="line">    [<span class="atom">cgiWrap</span> <span class="atom">setM_uiCgi</span>:<span class="number">0x412</span>];</span><br><span class="line"></span><br><span class="line">    <span class="name">MMServiceCenter</span> * <span class="atom">serviceCenter</span> = [<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>];</span><br><span class="line">    <span class="name">EventService</span> * <span class="atom">eventService</span> = [<span class="atom">serviceCenter</span> <span class="atom">getService</span>:[<span class="name">EventService</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="atom">unsigned</span> <span class="atom">int</span> <span class="atom">flag</span> = [<span class="atom">eventService</span> <span class="name">CreateProtobufEvent</span>:<span class="atom">cgiWrap</span> <span class="name">Flag</span>:<span class="number">0x5</span>];</span><br><span class="line">    <span class="atom">if</span> (<span class="atom">flag</span> != <span class="number">0x0</span>)&#123;</span><br><span class="line">        [<span class="name">CAppUtil</span> <span class="atom">addPBEventObserverListItem</span>:<span class="atom">flag</span> <span class="atom">andValue</span>:<span class="atom">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>展示微信运动好友供选择</strong>：微信中选择好友/群/公众号等等信息的时候都是使用的<strong>ContactSelectView</strong>，它内部会通过<strong>ContactsDataLogic</strong>获取所有的好友/群/公众号信息，然后实现<strong>ContactSelectViewDelegate</strong>协议的代理执行一个<code>- (_Bool)onFilterContactCandidate:(CContact *)arg1</code>操作，对传入的<strong>CContact</strong>进行筛选展示。因此，不同的控制器可以使用<strong>ContactSelectView</strong>实现选择所有好友，选择所有的聊天群等功能。</p>
<h3 id="5-非群主@所有人">5.非群主@所有人</h3><p>在群组中，只有群主才有@全体成员的功能，现在要增加非群主也可以使用@全体成员的功能。群主@全体成员就是通过修改群公告，先研究群主修改完了公告之后的发消息流程。<strong>ChatRoomInfoEditDescViewController</strong>类就是修改群公告的控制器，在点击『完成』按钮之后出来alert提示，然后可以hook<code>- (void)alertView:(id)arg1 clickedButtonAtIndex:(long long)arg2;</code>函数，使用hopper进行Decopmile 这个函数发现里面进行了如下操作：</p>
 <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGroupMgr * groupMgr = <span class="string">[[MMServiceCenter defaultCenter] getService:[CGroupMgr class]]</span>;</span><br><span class="line">NSString * usrName = self.m_chatRoomContact.m_nsUsrName;</span><br><span class="line">[groupMgr SetChatRoomDesc:usrName Desc:@<span class="string">"公告内容"</span> Flag:<span class="number">0x1</span>];</span><br></pre></td></tr></table></figure>
<p>去模拟一下这个操作，失败，究其原因应该是，只有群主的id才有权限去发送成功这个消息，并且一旦发送成功(以群主身份)，群公告也就会改变，这样也就只能作罢了。</p>
<p>另外去hook接收到的<code>群主@所有人的消息</code>的时候发现<strong>(CMessageWrap *)wrap</strong>的 <code>m_nsMsgSource</code> 属性内容为如下(这个属性是微信用来对聊天消息进行的一层xml包裹)：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">msgsource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">sequence_id</span>&gt;</span></span><br><span class="line">		656201926</span><br><span class="line">	<span class="tag">&lt;/<span class="title">sequence_id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">atuserlist</span>&gt;</span></span><br><span class="line">    	announcement@all</span><br><span class="line">	<span class="tag">&lt;/<span class="title">atuserlist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">msgsource</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要sequence_id，记录操作顺序的id，另外一个很明显的是『announcement -&gt; 群公告』，这个路看来只能再次作罢。</p>
<p>换一个研究方向，个人也是可以@个人的。这时候就是普通的发消息，但是其消息<code>wrap.m_nsMsgSource</code>为<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">msgsource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">atuserlist</span>&gt;</span></span><br><span class="line">        ***微信内部使用的用户id***</span><br><span class="line">    <span class="tag">&lt;/<span class="title">atuserlist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">msgsource</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果放入一个id就可以完成艾特该id的用户，那么是不是可以将当前群里面的所有人的<strong>内部用户id</strong>都放到这里面，达到@所有人的目的呢？</p>
<p>实验之后，可以的。</p>
<p>所以，下面要做的就是，获取当前群里面所有用户的<strong>内部用户id</strong>，拼成字符串，放入这个属性的xml中，而这个<strong>内部使用的用户id</strong>是<strong>CContact</strong>类的<code>m_nsUsrName</code>属性：<br> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSArray</span> *<span class="literal">result</span> = [%c(<span class="type">CContact</span>) getChatRoomMemberWithoutMyself:knToUsr];</span><br><span class="line"><span class="type">NSMutableString</span> *<span class="type">string</span> = [<span class="type">NSMutableString</span> <span class="type">string</span>];</span><br><span class="line">[<span class="literal">result</span> enumerateObjectsUsingBlock:^(<span class="type">CContact</span> * obj, <span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    [<span class="type">string</span> appendFormat:@<span class="string">",%@"</span>,[obj m_nsUsrName]];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="type">NSString</span> *sourceString = [<span class="type">string</span> substringFromIndex:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">[@<span class="string">"&lt;msgsource&gt;&lt;atuserlist&gt;%@&lt;/atuserlist&gt;&lt;/msgsource&gt;"</span> , sourceString];</span><br></pre></td></tr></table></figure></p>
<h3 id="6-消息预览">6.消息预览</h3><p>在公众号内部的网页浏览信息、看朋友圈的时候来了信息，需要退返回主页面，然后如果要回到公众号、朋友圈的位置就要一步步的返回回去。因此，对要跳转到聊天室的时候做一个记录浏览的记录，就可以在消息和网页浏览之间切换了。</p>
<p>需要hook到收到聊天消息的方法，自然是哪哪儿都有他的<code>-[CMessageMgr AsyncOnAddMsg:MsgWrap:]</code>了，然后在这里记录消息内容，使用通知的方法将事件广播出去。在需要的界面通过添加通知，对通知中的内容进行展示，提供一个视图，点击的时候可以调抓到对应的聊天室，跳转之前需要记录当前控制器的调用栈。</p>
<p>公众号阅读控制器为：<strong>MMWebViewController</strong>，朋友圈控制器为： <strong>WCTimeLineViewController</strong>，所以可以hook这两个控制器的<code>-viewDidLoad</code>方法，添加通知。</p>
<p>更加极端的是为所有控制器的父类<strong>MMUIViewController</strong>添加通知，但是在聊天室控制器<strong>BaseMsgContentViewController</strong>中移除通知，这样就可以达到为所有非聊天室界面提供消息预览的功能了。</p>
<p>这个思路是参考<a href="http://corbinchen.com/2016/02/26/我是如何利用Xcode调试开发微信消息预览插件的/" target="_blank" rel="external">这篇博文</a>理出来的，我只不过是改进了一些东西。但是这个思路中有一个bug：从公众号网页点击消息预览回到聊天室，再从聊天室回到公众号网页，然后公众号网页一步步pop到根视图控制器，再进入聊天室点击回到公众号网页按钮，会发现整个网页什么都没有，而且公众号聊天界面是黑的。目前还没有想出来解决办法。</p>
<p>另外，在破乎上微信相关的问题下面，有人建议阅读的时候，可以半屏幕显示聊天框，以实现一边看一边聊，这么不伦不类的功能，我觉得微信是不会做的。虽然在阅读公众号的时候来了新信息需要退出是很多用户的痛点，但基于聊天和公众号之间的本质区别，最多会加一个跳转功能，不可能一边阅读一边聊天。</p>
<p><a href="http://corbinchen.com/2016/02/26/我是如何利用Xcode调试开发微信消息预览插件的/" target="_blank" rel="external">参考文章：我是如何利用Xcode调试开发微信消息预览插件的</a></p>
<p>至于这么有强烈需求的功能，微信的团队从开始做公众号、企业号开始就没有考虑到么？基于聊天和阅读的本质区别，以及在微信中所扮演的角色有没有不同的权重值？可以参考一下👇产品经理们的理解。</p>
<p><a href="http://www.woshipm.com/pd/790772.html" target="_blank" rel="external">人人都是产品经理：想从微信文章快速跳到聊天，并没有你想象的那么容易</a></p>
<p><a href="http://www.woshipm.com/pd/787300.html" target="_blank" rel="external">人人都是产品经理：阅读时回复、快速搜索收藏、消息管理优化，这是我给微信做的3个交互改善意见</a></p>
<h3 id="7-自动回复">7.自动回复</h3><img src="/2017/09/11/hook-wechat/wechat_autoreply.png" alt="autoreply" title="autoreply">
<p>自动回复说白了，就是本地保存一个列表，列表中的每一个匹配规则类似于一个key-value，key是进行匹配的规则，使用正则匹配，value是匹配成功之后的回复消息。然后hook<code>-[CMessageMgr AsyncOnAddMsg:MsgWrap:]</code>判断接收到的消息内容去匹配本地列表，匹配成功了就返回对应要自动回复的内容。进行匹配的时候一定要有尽量多的判断条件，否则会引起<code>自己发给自己然后循环往复的自动回复</code>的bug。</p>
<p>为了避免上面提到的bug发生，除了在hook接收消息的时候严谨的判断，在设置匹配规则的时候也要尽可能的避免<code>.*</code>这种任何文本都可以匹配的正则表达式。另外为了防止误操作，仅支持单聊的时候对方发给自己消息的时候进行匹配，启动自动回复。</p>
<h3 id="8-调试工具">8.调试工具</h3><img src="/2017/09/11/hook-wechat/wechat_FLEX.png" alt="FLEX" title="FLEX">
<p>在看<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/CocoaPods" target="_blank" rel="external">wiki</a>的时候发现支持pods，例子就是调试工具<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">FLEX</a>，本来是打算使用系统提供的调试工具来实现调试功能的，但是，很明显，在release模式下，调试工具是没有用的，一直显示不出来。</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/</span></span><br><span class="line"></span><br><span class="line">Class debugCls = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIDebuggingInformationOverlay"</span>);</span><br><span class="line">[debugCls performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"prepareDebuggingOverlay"</span>)];</span><br></pre></td></tr></table></figure>
<p>按照wiki中的办法使用cocoaPods进行添加FLEX到项目中，然后就可以在微信中使用FLEX进行调试，很方便，并且还是开源的工具。</p>
<h3 id="9-为聊天面板增加插件">9.为聊天面板增加插件</h3><p>插件面板、输入框、表情等等都是加在<strong>SelectAttachmentViewController</strong>控制器中的，而<strong>SelectAttachmentViewController</strong>的view加到<strong>MMInputToolView</strong>上供显示、操作的,他们之间的事件回调使用的是<strong>SelectAttachmentViewControllerDelegate</strong>协议。<strong>MMInputToolView</strong>是加在聊天室控制器中的视图，他们之间的事件回调是使用的<strong>MMInputToolViewDelegate</strong>协议。</p>
<p><strong>SelectAttachmentViewController</strong>的<code>_arrAttachementObjectItems</code>变量是用来存储插件对象的，存储的对象为<strong>AttachementObjectItem</strong>类，这个对象中有目前我们自定义一个插件需要的所有：图片、文字、点击回调SEL：<br> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">AttachementObjectItem </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *nsTitle; <span class="comment">// @synthesize nsTitle=_nsTitle;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) UIImage *oImage; <span class="comment">// @synthesize oImage=_oImage;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) SEL selAction; <span class="comment">// @synthesize selAction=_selAction;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>结合以上可以理一下插件的事件响应顺序为：</p>
<ul>
<li>为<code>_arrAttachementObjectItems</code>数组添加的插件类中的selAction是插件在点击的时候</li>
<li>去询问控制器(SelectAttachmentViewController)的代理 (MMInputToolView)</li>
<li>然后代理(MMInputToolView)实现协议(SelectAttachmentViewControllerDelegate)中的方法</li>
<li>而且代理(MMInputToolView)自己也有他的代理，也就是聊天室控制器(BaseMsgContentViewController)</li>
<li>MMInputToolView再将事件传递给聊天控制器去实现插件中的操作，到此就完成了一个插件的事件调用链</li>
</ul>
<p>查看头文件发现<strong>SelectAttachmentViewController</strong>是在<code>-initObjectItem</code>方法中初始化添加插件对象到<code>_arrAttachementObjectItems</code>中的，所以，就从hook这个函数开始按照上面的逻辑添加插件。</p>
<p>那么下面就简单了，按照上面的逻辑</p>
<ol>
<li>hook <code>-initObjectItem</code>函数为<code>_arrAttachementObjectItems</code>数组添加一个自定义的插件对象</li>
<li>为<strong>MMInputToolView</strong>添加一个 <em>自定义插件中的需要响应的方法</em></li>
<li>为<strong>BaseMsgContentViewController</strong>添加一个<strong>MMInputToolView</strong>要传递过来的插件响应方法的方法</li>
</ol>
<img src="/2017/09/11/hook-wechat/wechat_attachment.png" alt="attachment" title="attachment">
<p>完成以上之后发现，群聊和单聊都添加了一个插件，很明显这不是想要的结果，需要想办法不为单聊添加自定义插件。那么对比一下群聊和单聊插件面板的差别可以发现：群聊可以群视频，群聊不可以转账，单聊只可以单个视频。使用FLEX查找发现不同的面板中有好几个属性是不一样的，不过其中一个<code>@property(nonatomic) _Bool allowMultiTalk;</code>属性的不同是很能区别出来是群聊还是单聊。实验一下，确实可以区分出来。</p>
<p>通过这个插件，可以为上面的<strong>@所有人</strong>功能在聊天室内添加更便捷的操作入口。</p>
<h3 id="10-表情相关">10.表情相关</h3><p>表情相关是直接使用的<a href="https://github.com/Mainstayz/WeChatWebEmoticon" target="_blank" rel="external">这个仓库</a>，里面有可以直接从web页面将图片(静态图、gif图)保存为表情，并且修改了表情最大限制尺寸。</p>
<p><a href="https://github.com/Mainstayz/WeChatWebEmoticon" target="_blank" rel="external">Github：一键保存为表情，无视微信表情大小的限制</a></p>
<h3 id="11-将已发送的文字朋友圈在私密/公开之间切换">11.将已发送的文字朋友圈在私密/公开之间切换</h3><img src="/2017/09/11/hook-wechat/wechat_timeline.png" alt="timeline" title="timeline">
<p>朋友圈的图片可以自由的进行『私密』-&gt;『公开』切换，但是文字却没有这个功能，一旦在是发送文字朋友圈的时候选择隐私，那么就一直是隐私，不可以再改为公开，相反，选择公开，就不可以再改为隐私。如果图片版可以自由切换，那么同为朋友圈的文字版应该也可以进行切换的。</p>
<p>首先，要找到图片版和文字版的区别和共同点。使用FLEX发现，图片和文字都有使用的<strong>WCDataItem</strong>来表示一条，不过由于图片版可能会有多张图片，所以他又包了一层，使用<strong>WCMediaItemWrap</strong>来表示，具体需要的东西如下：<br> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">WCDataItem </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *username;</span><br><span class="line"><span class="variable">@property</span>(nonatomic) _Bool isPrivate;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">WCMediaItemWrap </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int index;</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) WCDataItem *parent;</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) WCMediaItem *mediaItem;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p><strong>WCPhotoMutipleImageViewController</strong>是图片版本的控制器，里面的actionSheet回调里面有进行『私密/公开』的操作，hopper他的<code>- (void)actionSheet:(WCActionSheet *)arg1 clickedButtonAtIndex:(long long)arg2;</code>方法会发现，分别调用如下的方法:<br> <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 设为公开</span><br><span class="line">- (<span class="atom">void</span>)<span class="atom">onMakePublic</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="name">WCMediaItemWrap</span> * <span class="atom">mediaItemWrap</span> = [<span class="atom">self</span> <span class="atom">getMediaItemWrapAnywayAt</span>:<span class="atom">self</span>.<span class="atom">m_iCurrentPage</span>];</span><br><span class="line">    <span class="name">WCFacade</span> * <span class="atom">facade</span> = [[<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">getService</span>:[<span class="name">WCFacade</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="name">WCDataItem</span> * <span class="atom">parent</span> = <span class="atom">mediaItemWrap</span>.<span class="atom">parent</span>;</span><br><span class="line">    [<span class="atom">facade</span> <span class="atom">setDataItemPublic</span>:<span class="atom">parent</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设为隐私</span><br><span class="line">- (<span class="atom">void</span>)<span class="atom">onMakePrivate</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="name">WCMediaItemWrap</span> * <span class="atom">mediaItemWrap</span> = [<span class="atom">self</span> <span class="atom">getMediaItemWrapAnywayAt</span>:<span class="atom">self</span>.<span class="atom">m_iCurrentPage</span>];</span><br><span class="line">    <span class="name">WCFacade</span> * <span class="atom">facade</span> = [[<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">getService</span>:[<span class="name">WCFacade</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="name">WCDataItem</span> * <span class="atom">parent</span> = <span class="atom">mediaItemWrap</span>.<span class="atom">parent</span>;</span><br><span class="line">    [<span class="atom">facade</span> <span class="atom">setDataItemPrivate</span>:<span class="atom">parent</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就是里面的<strong>WCFacade</strong>类的<code>-setDataItemPrivate:(WCDataItem *)arg1</code>和<code>-setDataItemPublic:(WCDataItem *)arg1</code>这两个方法，而文字版本就是使用<strong>WCDataItem</strong>来表示的，所以，按道理传入文字版的<strong>WCDataItem</strong>实例就可以进行私密/公开的切换了。</p>
<p>结合以上<strong>WCFacade</strong>头文件中有价值的信息为：<br> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">WCFacade :</span> NSObject</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setDataItemPublic:</span>(WCDataItem *)arg1;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setDataItemPrivate:</span>(WCDataItem *)arg1;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure></p>
<p>接下来就可以在文字朋友圈详情界面进行添加操作入口。<strong>WCCommentDetailViewControllerFB</strong>就是文字版本详情控制器，他有一个属性<code>@property(retain, nonatomic) WCDataItem *dataItem;</code>代表当前的朋友圈数据，结合图片朋友圈隐私/公开的操作逻辑，可以使用这个属性来做私密/公开操作。</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文字朋友圈设为公开</span></span><br><span class="line">- (<span class="keyword">void</span>)_textDetailOnMakePublic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[self startLoadingBlocked];</span></span><br><span class="line">    W<span class="built_in">CFacade</span> * facade = [[MMServiceCenter defaultCenter] getService:[W<span class="built_in">CFacade</span> class]];</span><br><span class="line">    [facade setDataItemPublic:<span class="keyword">self</span><span class="variable">.dataItem</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文字朋友圈设为隐私</span></span><br><span class="line">- (<span class="keyword">void</span>)_textDetailOnMakePrivate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[self startLoadingBlocked];</span></span><br><span class="line">    W<span class="built_in">CFacade</span> * facade = [[MMServiceCenter defaultCenter] getService:[W<span class="built_in">CFacade</span> class]];</span><br><span class="line">    [facade setDataItemPrivate:<span class="keyword">self</span><span class="variable">.dataItem</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加以上的方法，经测试，发现是可以把文字版本朋友圈进行私密/公开的转换。</p>
<h3 id="12-聊天机器人">12.聊天机器人</h3><p>自动回复的升级版，todo</p>
<p><a href="http://blog.csdn.net/chenguolinblog/article/details/52071812" target="_blank" rel="external">CSDN：使用python基于web版如何制作机器人</a></p>
<p><a href="https://github.com/liuwons/wxBot" target="_blank" rel="external">Github：wxBot</a></p>
<p><a href="https://itchat.readthedocs.io/zh/latest/" target="_blank" rel="external">Github：itChat</a></p>
<p><a href="https://github.com/youfou/wxpy" target="_blank" rel="external">Github：wxpy</a></p>
<p><a href="http://www.tuling123.com" target="_blank" rel="external">图灵机器人</a></p>
<h3 id="13-一键开启/屏蔽【群、好友】消息">13.一键开启/屏蔽【群、好友】消息</h3><img src="/2017/09/11/hook-wechat/wechat_notify.png" alt="notify" title="notify">
<p>这个是在调试的时候想到的一个功能，因为要不断的切换屏蔽/开启来调试消息预览，然而开关又比较深：需要进入聊天详情，转换开关。聊天室内头部的聊天信息上有是否开启屏蔽的标志，是否可以将转换屏蔽的操作放到这个聊天信息上呢？期望的功能也不需要提示，如果屏蔽，点击立即开启，如果开启，点击立即屏蔽，没有任何复杂操作，最主要是不需要离开聊天室。微信将这个功能放到详情里面，是不是有自己深层次的考虑呢，还是没有想到呢，暂且不提这些，先分析一下这个功能如何实现。</p>
<p>单聊聊天室详情界面是<strong>AddContactToChatRoomViewController</strong>控制器，查看头文件通过关键字发现<code>-setUpdateNotifyMuted:</code>方法应该是用来控制是否开启屏蔽的，在转换的时候hook一下发现，的确是这个函数内部执行的操作，然后hopper一下整理出来内部实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)setUpdateNotifyMuted:(<span class="keyword">id</span>)arg2 </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.m_contact</span> setChatStatusNotifyOpen:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span><span class="variable">.m_delaySwitchLogic</span>)&#123;</span><br><span class="line">        <span class="built_in">NSString</span> * friendName = <span class="keyword">self</span><span class="variable">.m_chatRoomContact</span><span class="variable">.m_nsUsrName</span>;</span><br><span class="line">        <span class="built_in">BOOL</span>  isOpen = <span class="keyword">self</span><span class="variable">.m_chatRoomContact</span><span class="variable">.isChatStatusNotifyOpen</span>;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.m_delaySwitchLogic</span> chatProfileSwitchSetting:chatRoomName withType:<span class="number">0x2</span> andValue:!isOpen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>m_delaySwitchLogic</code>属性是<strong>DelaySwitchSettingLogic</strong>类直接<code>alloc-init</code>初始化的，因此如果在其他地方可以模拟这个操作了。另外对<strong>DelaySwitchSettingLogic</strong>也进行了hopper，发现里面的逻辑还是很复杂的。</p>
<p>群聊聊天室详情界面是<strong>ChatRoomInfoViewController</strong>控制器，其内部头文件中的<code>- (void)setMuteStatus:(id)arg1;</code>和<code>- (_Bool)setUpdateNotifyMuted:(_Bool)arg1</code>两个方法应该是设置屏蔽的操作，hook一下发现后者内部完成改变逻辑，然后使用hopper整理出来内部实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-setUpdateNotifyMuted:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span><span class="variable">.m_delaySwitchLogic</span>)&#123; <span class="comment">// DelaySwitchSettingLogic</span></span><br><span class="line">        <span class="built_in">NSString</span> * chatRoomName = <span class="keyword">self</span><span class="variable">.m_chatRoomContact</span><span class="variable">.m_nsUsrName</span>;</span><br><span class="line">        <span class="built_in">BOOL</span>  isOpen = <span class="keyword">self</span><span class="variable">.m_chatRoomContact</span><span class="variable">.isChatStatusNotifyOpen</span>;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.m_delaySwitchLogic</span> chatProfileSwitchSetting:chatRoomName withType:<span class="number">0x2</span> andValue:!isOpen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和单聊的<code>m_delaySwitchLogic</code>一样。</p>
<p>知道了以上的逻辑，下面就可以为聊天室的标题视图<code>self.navigationItem.titleView</code>添加手势，完成点击切换屏蔽消息的操作。但是在实际软件中<code>titleView</code>的frame很小，其子视图倒是很大，具体的结构如下</p>
<img src="/2017/09/11/hook-wechat/wechat_titleView.png" alt="titleView" title="titleView">
<p>子视图的显示区域已经超出了父视图，只能重写<strong>MMTitleView</strong>的<code>-hitTest:withEvent:</code>事件了。由于手势是加在了红色的视图上，因此在点击的时候会有一些小瑕疵，需要尽量的往右边一点。</p>
<h3 id="14-群主一键删除成员">14.群主一键删除成员</h3><p>群主删除成员需要三步，跳转两个界面：点击右上角进入群详情界面，点击删除进入选择群成员界面，挑选要删除的成员，然后完成删除。改进一下，不进行界面跳转，直接在聊天室内@要删除的成员，然后删除。并且这个功能不同于@所有人，只有群主才会拥有，因此在自定义聊天室插件的时候还要注意判断当前用户是不是群聊天的群主，参考<strong>SelectAttachmentViewController</strong>头文件可以可以添加一个属性<code>@property(nonatomic) _Bool mm_currentContactIsAdmin;</code>，因为这个类里面没有任何的关联聊天室身份的类，比如<strong>CContact</strong>，并且<strong>MMInputToolView</strong>中也没有，需要为他也添加一个属性。</p>
<p><strong>先分析一下选择群成员，然后执行删除的操作是如何完成的</strong>。选择群成员的控制器是<strong>RoomContactSelectViewController</strong>，完成选择，点击右上角弹出来alert，然而头文件中没有alert的代理回调方法，难道是使用的<strong>UIAlertController</strong>？再查看一下，貌似有用的仅仅有<code>- (void)OnDataChange;</code>这一个方法，感觉也不对，没办法，那直接hopper吧。</p>
<p>发现内部有一个方法内部有执行成员管理的操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)onDeleteMember:(<span class="built_in">NSArray</span> *)arg2 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.m_roomContact</span><span class="variable">.isAdmin</span>)&#123;</span><br><span class="line">      </span><br><span class="line">            [<span class="keyword">self</span> startLoadingNonBlock];</span><br><span class="line">            <span class="built_in">CGroupMgr</span> * groupMgr = [MMServiceCenter defaultCenter] getService:[<span class="built_in">CGroupMgr</span> class]];</span><br><span class="line">            [groupMgr DeleteGroupMember:chatRoomUsrName withMemberList:[<span class="built_in">NSArray</span> arrayWithObjects:arg2] scene:<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法内部使用了群组管理类<strong>CGroupMgr</strong>，hook一下他的<code>- (_Bool)DeleteGroupMember:(id)arg1 withMemberList:(id)arg2 scene:(unsigned long long)arg3;</code>函数发现，第一个参数是要删除的聊天室id，第二个参数是数组，里面是要删除的成员id，第三个参数是flag = 0。</p>
<p><strong>接下来需要获取已经艾特到的用户</strong>。需要获取到输入框中 @ 到的成员，长按成员头像可以将该用户放入输入框，查询头文件发现<code>- (void)longPressOnHeadImage:(id)arg1;</code>是调用的这个方法，使用hopper查看内部实现，将@到的用户交给<code>m_delegate</code>的<code>-addAtUser:</code>方法，为<strong>RoomContentLogicController</strong>，可以在这个长按方法里面<code>用数组进行记录@到的用户</code>，然后使用插件直接删除数组中的成员。但是有一个问题，输入框中是可以删除已有的@成员，也可以根据输入中含有<code>@字符</code>跳转界面供选择要艾特的成员，这样对数组的操作就需要考虑很多东西，比较麻烦。</p>
<p>输入框中输入<code>@字符</code>会跳转到选择提醒的好友列表，改列表是<strong>RoomContactSelectViewController</strong>控制器，在点击对应的成员的时候，通过协议<strong>RoomContactSelectDelegate</strong>中的<code>- (void)didSelectContact:(CBaseContact *)arg1;</code>回调告诉代理选中了某一个成员，他的代理为<strong>RoomContentLogicController</strong>，而前面在长按用户头像也是将用户交给的这个类，那么hopper他看一下内部是做了何种操作：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)AddAtUser:(CContact *)arg2 </span><br><span class="line">&#123;</span><br><span class="line">    MMNewSessionMgr * newSesMgr = <span class="string">[[MMServiceCenter defaultCenter]getService:[MMNewSessionMgr class]]</span>;</span><br><span class="line">    [newSesMgr addContact:self.m_contact AtUser:arg2.m_usrName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来查询<strong>MMNewSessionMgr</strong>头文件发现，可以通过聊天室id获取一个<code>sessionInfo</code>，<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">interface</span> MMNewSessionMgr : NSObject</span>&#123;</span><br><span class="line">    <span class="tag">NSMutableArray</span> *<span class="tag">m_arrSession</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">addContact</span>:<span class="value">(CContact *)arg2 AtUser:(NSString *)usrName</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">MMSessionInfo</span> *)<span class="rule"><span class="attribute">GetSessionByUserName</span>:<span class="value">(NSString *)chatRoomUsrName</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>MMSessionInfo</strong>类的内部有一个属性，在进行艾特好友的时候会变化，<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">MMSessionInfo </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *m_atUserList; <span class="comment">// @synthesize m_atUserList;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>虽然通过这个属性可以拿到已经艾特的成员，但是如果如果输入框中将已经艾特的用户删除，这个属性中并没有删除。看来还是需要再找找了。</p>
<p>到这里看不下4个类之间的回调关系以及他们的汇编代码，我都快疯了。偷懒的话，可以直接在点击删除的时候去遍历输入框内的文本，使用正则找出来已经艾特的群成员(成员的昵称)，然后去获取这些群成员的id，执行上面的删除操作。仅仅是取巧的办法，没有从根本上实现功能，有可能会有bug。</p>
<h3 id="15-一键为微信运动好友点赞">15.一键为微信运动好友点赞</h3><img src="/2017/09/11/hook-wechat/wechat_sportlike.png" alt="sportlike" title="sportlike">
<p>有一个以前不知道因为什么原因加的好友，微信运动每天晚上8点多给我点赞，连着几个星期之后，我觉得他是在做一个类似于打卡的行为，每天坚持运动，完了为微信运动中所有的好友点赞，打卡完成。既然用户有这样的需求，就可以试着把这个功能加入到软件中。</p>
<p>先分析一下为一个好友点赞的操作。排行榜控制器类为<strong>BraceletRankViewController</strong>，头文件中的<code>-(void)onClickLike:(id)arg1;</code>方法看起来是点击红心的操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- onClickLike:(BraceletRankLikeButton *)arg&#123;</span><br><span class="line">	DeviceRankInfo * rankInfo = arg<span class="variable">.m_rankInfo</span>;</span><br><span class="line">	<span class="keyword">if</span>(is_click_self)&#123;</span><br><span class="line">      <span class="comment">// 跳转到为自己点赞的列表</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != rankInfo<span class="variable">.score</span> &amp;&amp; rankInfo<span class="variable">.hasLike</span>)&#123;<span class="comment">// 已经点过赞了的</span></span><br><span class="line">          <span class="built_in">BOOL</span> contains = [<span class="keyword">self</span><span class="variable">.friendLikeSet</span> containsObject:rankInfo];</span><br><span class="line">          <span class="built_in">NSUinterger</span> likeCount = rankInfo<span class="variable">.likeCount</span>;</span><br><span class="line">          <span class="keyword">if</span> (contains)&#123;</span><br><span class="line">            <span class="comment">//likeCount</span></span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.friendLikeSet</span> removeObject:rankInfo];</span><br><span class="line">            [<span class="keyword">self</span> animatChangeLikeStateForUser: itToLikeState:<span class="literal">NO</span>];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 还没有点赞</span></span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.friendLikeSet</span> addObject:rankInfo];</span><br><span class="line">            [<span class="keyword">self</span> animatChangeLikeStateForUser: itToLikeState:<span class="literal">YES</span>];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数内部通过判断已经点赞的话就从一个集合(<code>friendLikeSet</code>)中移除，没有点赞就加入集合，然后调了一个函数<code>-animatChangeLikeStateForUser:isTolikeState:</code>，通过函数名字可以猜出来，做数据上传的可能性不是很大，只是根据参数做了一个视图动画。现在知道了，被点赞的好友会被放入一个集合中，通过FLEX查看到是以<strong>DeviceRankInfo</strong>类的实例来表示的，涉及到的类如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">DeviceRankInfo </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(nonatomic) _Bool hasLike; <span class="comment">// @synthesize hasLike=_hasLike;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *username; <span class="comment">// @synthesize username=_username;</span></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">BraceletRankLikeButton </span>: MMUIButton</span><br><span class="line"><span class="variable">@property</span>(retain) DeviceRankInfo *m_rankInfo; <span class="comment">// @synthesize m_rankInfo;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>全局搜索<code>friendLikeSet</code>发现，在视图消失的时候有进行数据的上传：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="keyword">id</span>)arg2 &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.friendLikeSet</span> != <span class="literal">nil</span>)&#123;</span><br><span class="line">      <span class="built_in">NSUInterger</span> count = <span class="keyword">self</span><span class="variable">.friendLikeSet</span><span class="variable">.count</span>;</span><br><span class="line">      <span class="keyword">if</span> (count)&#123;</span><br><span class="line">        ...</span><br><span class="line">        DeviceRankSnsMgr * rankSnsMgr = [[MMServiceCenter defaultCenter]getService:[DeviceRankSnsMgr class]];</span><br><span class="line">        [rankSnsMgr likeFriendRank:<span class="keyword">self</span><span class="variable">._rankId</span> FriendUsernames:<span class="string">@""</span> brandUserName:<span class="string">@""</span> optype:<span class="number">0x1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面通过服务中心中的<strong>DeviceRankSnsMgr</strong>调用了<code>-likeFriendRank:FriendUsernames:brandUserName:optype:</code>函数，hook一下该函数发现参数为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DeviceRankSnsMgr</span> : <span class="title">MMService</span></span></span><br><span class="line">- (<span class="keyword">void</span>)likeFriendRank:(<span class="built_in">NSStirng</span> *)arg1 FriendUsernames:(<span class="built_in">NSArray</span> *)arg2 brandUserName:(<span class="built_in">NSString</span> *)arg3 optype:(<span class="keyword">unsigned</span> <span class="keyword">int</span>)arg4;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">第一个参数为 BraceletRankViewController 的 _rankId 属性，</span><br><span class="line">第二个参数为要点赞的好友数组，内部装的是用户<span class="keyword">id</span></span><br><span class="line">第三个传空字符串</span><br><span class="line">第四个传<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因此，只需要获取到所有排行榜中好友的id放入数组，使用<strong>DeviceRankSnsMgr</strong>的这个方法就可以为所有的好友进行点赞。</p>
<hr>
<blockquote>
<p>以上这些功能希望能有助于看官更加舒服的使用微信。</p>
<p>能看到这里的，估计都是动手能力很强的，那么何尝不开始使用<a href="https://github.com/AloneMonkey/MonkeyDev.git" target="_blank" rel="external">MonkeyDev</a>客制化一个属于自己的微信呢。</p>
</blockquote>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/学习/">学习</a>, <a class="tag-link" href="/tags/微信/">微信</a>, <a class="tag-link" href="/tags/逆向/">逆向</a></div></article></div><div class="post-nav"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/2017/08/05/sketch/" class="next-post">使用Sketch进行设计学习</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>