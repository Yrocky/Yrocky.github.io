<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">微信，让生活更美好  插件，让微信更方便</h1><div class="post-info">9月 11日 2017</div><div class="post-entry"><img src="/2017/09/11/hook-wechat/wechat_title_no_bg.png" alt="title" title="title">
<p>不得不说，微信现在已经成为了生活中至关重要的一个工具。在使用的时候难免会想要一些个性化的功能，但是这些功能原版app内没有提供，那么就要靠自己动手了。恰巧前段时间看到<a href="http://iosre.com/t/topic/8696" target="_blank" rel="external">逆向社区</a>中的大大们在iosOpenDev基础上整出了个更加好用的<a href="https://github.com/AloneMonkey/MonkeyDev.git" target="_blank" rel="external">MonkeyDev</a>，由于iOSOpenDev不再更新引起的很多不便和搞事情前配置各种麻烦的命令让我都快放弃逆向了，这个新的Dev让我又有了玩一把的心思。</p>
<p>使用MonkeyDev将以前的一些tweak放进去编译之后可以完美的跑在手机上了，现在真的是有点傻瓜操作了，逆向你只需要关心如何将自己的想法hook出来，其余的繁复操作都交给Dev就好了。那好了，这次就好好体验一下MonkeyDev写一个微信助手的tweak，代码基本不会贴出来，hook的思路会一步一步的列出来，功能的话都是一些有实际需求但不知道可不可以实现的😜，不过80%在探索后都可以实现。</p>
<p>涉及到的功能不包括：各种姿势抢红包、防止消息撤回、修改微信步数、群聊黑名单，因为这些功能都已经有很详细的教程讲解了，并且如果微信不改版，基本的hook思路是不会变的。虽然不会涉及到这些，但是也会将前人的思路整理列出来，以供查阅学习。另外针对于修改微信步数，我做了一个更加有趣的可玩功能，虽然是改步数，但是也要改的不那么明显。</p>
<p>here we go.</p>
<a id="more"></a>
<h3 id="自动抢红包">自动抢红包</h3><p>思路大致为：hook收到红包的消息—&gt;进行红包解析—&gt;模拟执行抢的操作</p>
<p><a href="http://www.jianshu.com/p/189afbe3b429" target="_blank" rel="external">简书：一步步实现微信抢红包(非越狱)</a></p>
<p><a href="http://www.jianshu.com/p/677287a002be" target="_blank" rel="external">简书：微信红包实现原理</a></p>
<p><a href="https://github.com/buginux/WeChatRedEnvelop" target="_blank" rel="external">Github：Tweak源码</a></p>
<h3 id="防止消息撤回">防止消息撤回</h3><p>思路为：hook收到【撤回消息】的消息，不执行删除消息的操作，然后添加一个本地消息提示阻止了一条消息撤回。</p>
<p><a href="http://www.jianshu.com/p/7f65287a2e7a" target="_blank" rel="external">简书：Mac版微信防消息撤回  文章中有github地址</a></p>
<h3 id="群聊黑名单">群聊黑名单</h3><p>大致思路为：使用一个数组记录选择的黑名单到本地，hook获取消息的方法，如果是群聊消息且在数组中，就直接返回。</p>
<p><a href="https://github.com/buginux/WeChatRedEnvelop" target="_blank" rel="external">Github：Tweak源码</a></p>
<h3 id="花样修改微信步数">花样修改微信步数</h3><p>所有的修改微信步数的操作都是在获取在微信步数的时候hook，然后想要展示的数字。</p>
<p>对比这种太过痕迹化的改步数，在修改步数的时候增加一些可玩性的操作，让修改步数不那么明显。除了基础的固定步数，主要的玩法有两个：与『第一名』、『最后一名』、『任意一名』多/少n步；选择排行榜中的某一个人比他多/少n步。这些都是逻辑的处理，没什么可说的，看官也可以按照自己的想法编写一套逻辑来修改步数。</p>
<h3 id="主要的难点在于获取加入微信运动排行榜的所有用户供选择，这个既然微信运动排行榜中有，那么就可以获取到。">主要的难点在于获取加入微信运动排行榜的所有用户供选择，这个既然微信运动排行榜中有，那么就可以获取到。</h3><p><strong>获取微信运动好友列表</strong>：在排行榜中获取好友列表的时候是使用的主动请求，具体的如何请求都放在了<strong>类里面</strong>，所以可以使用这个类进行模拟获取微信运动好友列表。</p>
<p><strong>展示微信运动好友供选择</strong>：微信中选择好友/群/公众号等等信息的时候都是使用的<strong>ContactSelectView</strong>，它内部会通过<strong>ContactsDataLogic</strong>获取所有的好友/群/公众号信息，然后实现<strong>ContactSelectViewDelegate</strong>协议的代理执行一个<code>- (_Bool)onFilterContactCandidate:(CContact *)arg1</code>操作，对传入的<strong>CContact</strong>进行筛选展示。</p>
<h3 id="非群主@所有人">非群主@所有人</h3><p>在群组中，只有群主才有@全体成员的功能，现在要增加非群主也可以使用@全体成员的功能。群主@全体成员就是通过修改群公告，先研究群主修改完了公告之后的发消息流程。<strong>ChatRoomInfoEditDescViewController</strong>类就是修改群公告的控制器，在点击『完成』按钮之后出来alert提示，然后可以hook<code>- (void)alertView:(id)arg1 clickedButtonAtIndex:(long long)arg2;</code>函数，使用hopper进行Decopmile 这个函数发现里面进行了如下操作：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGroupMgr * groupMgr = <span class="string">[[MMServiceCenter defaultCenter] getService:[CGroupMgr class]]</span>;</span><br><span class="line">NSString * usrName = self.m_chatRoomContact.m_nsUsrName;</span><br><span class="line">[groupMgr SetChatRoomDesc:usrName Desc:@<span class="string">"公告内容"</span> Flag:<span class="number">0x1</span>];</span><br></pre></td></tr></table></figure>
<p>去模拟一下这个操作，失败，究其原因应该是，只有群主的id才有权限去发送成功这个消息，并且一旦发送成功(以群主身份)，群公告也就会改变，这样也就只能作罢了。</p>
<p>另外去hook接收到的<code>群主@所有人的消息</code>的时候发现<strong>(CMessageWrap *)wrap</strong>的 <code>m_nsMsgSource</code> 属性内容为如下(这个属性是微信用来对聊天消息进行的一层xml包裹)：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;msgsource&gt;</span><span class="variable">&lt;sequence_id&gt;</span><span class="number">656481926</span><span class="variable">&lt;/sequence_id&gt;</span></span><br><span class="line">    <span class="variable">&lt;atuserlist&gt;</span>announcement@<span class="literal">all</span><span class="variable">&lt;/atuserlist&gt;</span></span><br><span class="line"><span class="variable">&lt;/msgsource&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要sequence_id，记录操作顺序的id，另外一个很明显的是『announcement -&gt; 群公告』，这个路看来只能再次作罢。</p>
<p>换一个研究方向，个人也是可以@个人的。这时候就是普通的发消息，但是其消息<code>wrap.m_nsMsgSource</code>为<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;msgsource&gt;</span></span><br><span class="line">    <span class="variable">&lt;atuserlist&gt;</span></span><br><span class="line">        <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>微信内部使用的用户id<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">    <span class="variable">&lt;/atuserlist&gt;</span></span><br><span class="line"><span class="variable">&lt;/msgsource&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果放入一个id就可以完成艾特改id的用户，是不是可以将当前群里面的所有人的<strong>内部用户id</strong>都放到这里面，达到@所有人的目的呢？</p>
<p>实验之后，可以的。</p>
<p>所以，下面要做的就是，获取当前群里面所有用户的<strong>内部用户id</strong>，拼成字符串，放入这个属性的xml中，而这个<strong>内部使用的用户id</strong>是<strong>CContact</strong>类的<code>m_nsUsrName</code>属性：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSArray</span> *<span class="literal">result</span> = [%c(<span class="type">CContact</span>) getChatRoomMemberWithoutMyself:knToUsr];</span><br><span class="line"><span class="type">NSMutableString</span> *<span class="type">string</span> = [<span class="type">NSMutableString</span> <span class="type">string</span>];</span><br><span class="line">[<span class="literal">result</span> enumerateObjectsUsingBlock:^(<span class="type">CContact</span> * obj, <span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    [<span class="type">string</span> appendFormat:@<span class="string">",%@"</span>,[obj m_nsUsrName]];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="type">NSString</span> *sourceString = [<span class="type">string</span> substringFromIndex:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">[@<span class="string">"&lt;msgsource&gt;&lt;atuserlist&gt;%@&lt;/atuserlist&gt;&lt;/msgsource&gt;"</span> , sourceString];</span><br></pre></td></tr></table></figure></p>
<h3 id="消息预览">消息预览</h3><p><a href="http://corbinchen.com/2016/02/26/我是如何利用Xcode调试开发微信消息预览插件的/" target="_blank" rel="external">参考文章：我是如何利用Xcode调试开发微信消息预览插件的</a></p>
<h3 id="自动回复">自动回复</h3><h3 id="调试工具">调试工具</h3><p>在看到<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/CocoaPods" target="_blank" rel="external">wiki</a>的时候发现支持pods，例子就是调试工具<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">FLEX</a>，本来是打算使用系统提供的调试工具来实现调试功能的，但是，很明显，在release模式下，调试工具是没有用的，一直显示不出来。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/</span></span><br><span class="line"></span><br><span class="line">Class debugCls = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIDebuggingInformationOverlay"</span>);</span><br><span class="line">[debugCls performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"prepareDebuggingOverlay"</span>)];</span><br></pre></td></tr></table></figure>
<p>按照wiki中的办法使用cocoaPods进行添加FLEX到项目中，然后就可以在微信中使用FLEX进行调试，很方便，并且还是开源的工具。</p>
<h3 id="为聊天面板增加插件">为聊天面板增加插件</h3><p>插件面板、输入框、表情等等都是加在<strong>SelectAttachmentViewController</strong>控制器中的，而<strong>SelectAttachmentViewController</strong>的view加到<strong>MMInputToolView</strong>上供显示、操作的,他们之间的事件回调使用的是<strong>SelectAttachmentViewControllerDelegate</strong>协议。<strong>MMInputToolView</strong>是加在聊天室控制器中的视图，他们之间的事件回调是使用的<strong>MMInputToolViewDelegate</strong>协议。</p>
<p><strong>SelectAttachmentViewController</strong>的<code>_arrAttachementObjectItems</code>变量是用来存储插件对象的，存储的对象为<strong>AttachementObjectItem</strong>类，这个对象中有目前我们自定义一个插件需要的所有：图片、文字、点击回调SEL：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">AttachementObjectItem </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *nsTitle; <span class="comment">// @synthesize nsTitle=_nsTitle;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) UIImage *oImage; <span class="comment">// @synthesize oImage=_oImage;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) SEL selAction; <span class="comment">// @synthesize selAction=_selAction;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>结合以上可以理一下插件的事件响应顺序为：</p>
<ul>
<li>为<code>_arrAttachementObjectItems</code>数组添加的插件类中的selAction是插件在点击的时候</li>
<li>去询问控制器(SelectAttachmentViewController)的代理 (MMInputToolView)</li>
<li>然后代理(MMInputToolView)实现协议(SelectAttachmentViewControllerDelegate)中的方法</li>
<li>而且代理(MMInputToolView)自己也有他的代理，也就是聊天室控制器(BaseMsgContentViewController)</li>
<li>MMInputToolView再将事件传递给聊天控制器去实现插件中的操作，到此就完成了一个插件的事件调用链</li>
</ul>
<p>查看头文件发现<strong>SelectAttachmentViewController</strong>是在<code>-initObjectItem</code>方法中初始化添加插件对象到<code>_arrAttachementObjectItems</code>中的，所以，就从hook这个函数开始按照上面的逻辑添加插件。</p>
<p>那么下面就简单了，按照上面的逻辑</p>
<ol>
<li>hook <code>-initObjectItem</code>函数为<code>_arrAttachementObjectItems</code>数组添加一个自定义的插件对象</li>
<li>为<strong>MMInputToolView</strong>添加一个 <em>自定义插件中的需要响应的方法</em></li>
<li>为<strong>BaseMsgContentViewController</strong>添加一个<strong>MMInputToolView</strong>要传递过来的插件响应方法的方法</li>
</ol>
<img src="/2017/09/11/hook-wechat/attachment.png" alt="attachment" title="attachment">
<p>完成以上之后发现，群聊和单聊都添加了一个插件，很明显这不是想要的结果，需要想办法不为单聊添加自定义插件。那么对比一下群聊和单聊插件面板的差别可以发现：<strong>群聊插件面板中没有转账插件</strong>。使用FLEX查找发现不同的面板中个属性是不一样的。但是，会发现有很多bool值都不一样，不过其中一个<code>@property(nonatomic) _Bool allowMultiTalk;</code>属性的不同是很能区别出来是群聊还是单聊。实验一下，确实可以区分出来。</p>
<p>通过这个插件，可以为上面的<strong>@所有人</strong>功能在聊天室内添加入口。</p>
<h3 id="表情相关">表情相关</h3><h3 id="将已发送的文字朋友圈在私密/公开之间切换">将已发送的文字朋友圈在私密/公开之间切换</h3><p>朋友圈的图片可以自由的进行『私密』-&gt;『公开』切换，但是文字却没有这个功能，一旦在是发送文字朋友圈的时候选择隐私，那么就一直是隐私，不可以再改为公开，相反，选择公开，就不可以再改为隐私。如果图片可以自由切换，那么同为朋友圈的文字版应该也可以进行切换的。</p>
<p>首先，要找到图片版和文字版的区别和共同点。使用FLEX发现，图片和文字都有使用的<strong>WCDataItem</strong>来表示一条，不过图片中是又包了一层，使用<strong>WCMediaItemWrap</strong>来表示，具体需要的东西如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCDataItem</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(retain, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *username;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) _Bool isPrivate;</span><br><span class="line">- (<span class="keyword">id</span>)itemID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCMediaItemWrap</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">@property</span>(retain, <span class="keyword">nonatomic</span>) WCDataItem *parent;</span><br><span class="line"><span class="keyword">@property</span>(retain, <span class="keyword">nonatomic</span>) WCMediaItem *mediaItem;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><strong>WCPhotoMutipleImageViewController</strong>是图片版本的控制器，里面的actionSheet回调里面有进行『私密/公开』的操作，hopper他的<code>- (void)actionSheet:(WCActionSheet *)arg1 clickedButtonAtIndex:(long long)arg2;</code>方法会发现，分别调用如下的方法:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 设为公开</span><br><span class="line">- (<span class="atom">void</span>)<span class="atom">onMakePublic</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="name">WCMediaItemWrap</span> * <span class="atom">mediaItemWrap</span> = [<span class="atom">self</span> <span class="atom">getMediaItemWrapAnywayAt</span>:<span class="atom">self</span>.<span class="atom">m_iCurrentPage</span>];</span><br><span class="line">    <span class="name">WCFacade</span> * <span class="atom">facade</span> = [[<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">getService</span>:[<span class="name">WCFacade</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="name">WCDataItem</span> * <span class="atom">parent</span> = <span class="atom">mediaItemWrap</span>.<span class="atom">parent</span>;</span><br><span class="line">    [<span class="atom">facade</span> <span class="atom">setDataItemPublic</span>:<span class="atom">parent</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设为隐私</span><br><span class="line">- (<span class="atom">void</span>)<span class="atom">onMakePrivate</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="name">WCMediaItemWrap</span> * <span class="atom">mediaItemWrap</span> = [<span class="atom">self</span> <span class="atom">getMediaItemWrapAnywayAt</span>:<span class="atom">self</span>.<span class="atom">m_iCurrentPage</span>];</span><br><span class="line">    <span class="name">WCFacade</span> * <span class="atom">facade</span> = [[<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">getService</span>:[<span class="name">WCFacade</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="name">WCDataItem</span> * <span class="atom">parent</span> = <span class="atom">mediaItemWrap</span>.<span class="atom">parent</span>;</span><br><span class="line">    [<span class="atom">facade</span> <span class="atom">setDataItemPrivate</span>:<span class="atom">parent</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就是里面的<strong>WCFacade</strong>类的<code>-setDataItemPrivate:(WCDataItem *)arg1</code>和<code>-setDataItemPublic:(WCDataItem *)arg1</code>这两个方法，而文字版本就是使用<strong>WCDataItem</strong>来表示的，所以，按道理传入文字版的<strong>WCDataItem</strong>实例就可以进行私密/公开的切换了。</p>
<p>结合以上<strong>WCFacade</strong>头文件中有价值的信息为：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">WCFacade :</span> NSObject</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setDataItemPublic:</span>(WCDataItem *)arg1;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setDataItemPrivate:</span>(WCDataItem *)arg1;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure></p>
<p>接下来就可以在文字朋友圈详情界面进行添加操作入口。<strong>WCCommentDetailViewControllerFB</strong>就是文字版本详情控制器，他有一个属性<code>@property(retain, nonatomic) WCDataItem *dataItem;</code>代表当前的朋友圈数据，结合图片朋友圈隐私/公开的操作逻辑，可以使用这个属性来做私密/公开操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文字朋友圈设为公开</span></span><br><span class="line">- (<span class="keyword">void</span>)_textDetailOnMakePublic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[self startLoadingBlocked];</span></span><br><span class="line">    W<span class="built_in">CFacade</span> * facade = [[MMServiceCenter defaultCenter] getService:[W<span class="built_in">CFacade</span> class]];</span><br><span class="line">    [facade setDataItemPublic:<span class="keyword">self</span><span class="variable">.dataItem</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文字朋友圈设为隐私</span></span><br><span class="line">- (<span class="keyword">void</span>)_textDetailOnMakePrivate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[self startLoadingBlocked];</span></span><br><span class="line">    W<span class="built_in">CFacade</span> * facade = [[MMServiceCenter defaultCenter] getService:[W<span class="built_in">CFacade</span> class]];</span><br><span class="line">    [facade setDataItemPrivate:<span class="keyword">self</span><span class="variable">.dataItem</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加以上的方法，经测试，发现是可以把文字版本朋友圈进行私密/公开的转换。</p>
<h3 id="聊天机器人">聊天机器人</h3><p>是自动回复的升级版，todo</p>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/学习/">学习</a>, <a class="tag-link" href="/tags/微信/">微信</a>, <a class="tag-link" href="/tags/逆向/">逆向</a></div></article></div><div class="post-nav"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/2017/08/05/sketch/" class="next-post">使用Sketch进行设计学习</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>