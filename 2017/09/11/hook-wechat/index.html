<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">微信，让生活更美好  插件，让微信更方便</h1><div class="post-info">9月 11日 2017</div><div class="post-entry"><img src="/2017/09/11/hook-wechat/wechat_title.png" alt="title" title="title">
<p>不得不说，微信现在已经成为了生活中至关重要的一个工具。在使用的时候难免会想要一些个性化的功能，但是这些功能原版app内没有提供，那么就要靠自己动手了。恰巧前段时间看到<a href="http://iosre.com/t/topic/8696" target="_blank" rel="external">逆向社区</a>中的大大们在iOSOpenDev基础上整出了个更加好用的<a href="https://github.com/AloneMonkey/MonkeyDev.git" target="_blank" rel="external">MonkeyDev</a>，由于iOSOpenDev不再更新引起的很多不便和搞事情前配置各种麻烦的命令让我都快放弃逆向了，这个新的Dev让我又有了玩一把的心思。</p>
<p>使用MonkeyDev将以前的一些tweak放进去编译之后可以完美的跑在手机上了，现在逆向真的是有点傻瓜操作了，只需要关心如何将自己的想法hook出来，其余的繁复操作都交给Dev就好了。那好了，这次就好好体验一下MonkeyDev写一个微信助手的tweak，hook的思路会一步一步的列出来，代码基本不会贴出来，功能的话都是一些有实际需求但不知道可不可以实现的😜，不过80%在探索后都可以实现。</p>
<p>涉及到的功能不包括：各种姿势抢红包、防止消息撤回、修改微信步数、群聊黑名单，因为这些功能都已经有很详细的教程讲解了，并且如果微信不改版，基本的hook思路是不会变的。虽然不会涉及到这些，但是也会将前人的思路整理列出来，以供查阅学习。另外针对于修改微信步数，我做了一个更加有趣的可玩功能，虽然是改步数，但是也要改的不那么明显。</p>
<p>here we go.</p>
<a id="more"></a>
<h3 id="1-自动抢红包">1.自动抢红包</h3><p>思路大致为：hook收到红包的消息—&gt;进行红包解析—&gt;模拟执行抢的操作</p>
<p><a href="http://www.jianshu.com/p/189afbe3b429" target="_blank" rel="external">简书：一步步实现微信抢红包(非越狱)</a></p>
<p><a href="http://www.jianshu.com/p/677287a002be" target="_blank" rel="external">简书：微信红包实现原理</a></p>
<p><a href="https://github.com/buginux/WeChatRedEnvelop" target="_blank" rel="external">Github：Tweak源码</a></p>
<h3 id="2-防止消息撤回">2.防止消息撤回</h3><p>思路为：hook收到【撤回消息】的消息，不执行删除消息的操作，然后添加一个本地消息提示阻止了一条消息撤回。</p>
<p><a href="http://www.jianshu.com/p/7f65287a2e7a" target="_blank" rel="external">简书：Mac版微信防消息撤回  文章中有github地址</a></p>
<h3 id="3-群聊黑名单">3.群聊黑名单</h3><p>大致思路为：使用一个数组记录选择的黑名单到本地，hook获取消息的方法，如果是群聊消息且在数组中，就直接返回。</p>
<p><a href="https://github.com/buginux/WeChatRedEnvelop" target="_blank" rel="external">Github：Tweak源码</a></p>
<h3 id="4-花样修改微信步数">4.花样修改微信步数</h3><p>所有的修改微信步数的操作都是在获取在微信步数的时候hook，然后想要展示的数字。</p>
<p>对比这种太过痕迹化的改步数，在修改步数的时候增加一些可玩性的操作，让修改步数不那么明显。除了基础的固定步数，主要的玩法有两个：与『第一名』、『最后一名』、『任意一名』多/少n步；选择排行榜中的某一个人比他多/少n步。这些都是逻辑的处理，没什么可说的，看官也可以按照自己的想法编写一套逻辑来修改步数。</p>
<p>主要的难点在于获取加入微信运动排行榜的所有用户供选择，这个既然微信运动排行榜中有，那么就可以获取到。</p>
<p><strong>获取微信运动好友列表</strong>：在排行榜中获取好友列表的时候是使用的主动请求，具体的如何请求都放在了<strong>DeviceRankSnsMgr</strong>类里面，所以可以使用这个类进行模拟获取微信运动好友列表。请求排行版是通过这个类的<code>- (void)getUserRankListCount:(id)arg1 chanpionUsername:(id)arg2 brandUserName:(id)arg3</code>方法发出的，对于这个请求的响应是<code>- (void)handleRankGetUserRankLikeResponse:(ProtobufCGIWrap *)arg1</code>回调，其中<strong>ProtobufCGIWrap</strong>的有用信息如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">ProtobufCGIWrap </span>: NSObject </span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) GetUserRankLikeCountResponse *m_pbResponse; <span class="comment">// @synthesize m_pbResponse;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) GetUserRankLikeCountRequest *m_pbRequest; <span class="comment">// @synthesize m_pbRequest;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int m_uiCgi; <span class="comment">// @synthesize m_uiCgi;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>很明显，<code>m_pbResponse</code>和<code>m_pbRequest</code>分别指代的响应和请求，这两个属性对应的类如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">GetUserRankLikeCountRequest </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *appusername; <span class="comment">// @dynamic appusername;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *championname; <span class="comment">// @dynamic championname;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *rankid; <span class="comment">// @dynamic rankid;</span></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">likeItem </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int likecount; <span class="comment">// @dynamic likecount;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int likestate; <span class="comment">// @dynamic likestate;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int ranknum; <span class="comment">// @dynamic ranknum;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int score; <span class="comment">// @dynamic score;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *username; <span class="comment">// @dynamic username;</span></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">GetUserRankLikeCountResponse </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSMutableArray *follows; <span class="comment">// 关注的好友排行信息 &lt;Follow *&gt;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSMutableArray &lt;likeItem *&gt;*friendlikelist; <span class="comment">// @dynamic friendlikelist;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSMutableArray *likeuserlist; <span class="comment">// @dynamic likeuserlist;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *rankid; <span class="comment">// @dynamic rankid;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>到此已经可以直到如何进行请求，以及获取到什么样的数据。接着hopper<strong>DeviceRankSnsMgr</strong>的发送请求函数可以大致理出来微信发送请求的方式：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="atom">void</span>)<span class="atom">getUserRankListCount</span>:(<span class="atom">id</span>)<span class="atom">arg1</span> <span class="atom">chanpionUsername</span>:(<span class="atom">id</span>)<span class="atom">arg2</span> <span class="atom">brandUserName</span>:(<span class="atom">id</span>)<span class="atom">arg3</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="name">GetUserRankLikeCountRequest</span> * <span class="atom">request</span> = [[<span class="name">GetUserRankLikeCountRequest</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">    [<span class="atom">request</span> <span class="atom">setRankid</span>:@<span class="string">"latestRank"</span>];</span><br><span class="line">    [<span class="atom">request</span> <span class="atom">setAppusername</span>:@<span class="string">""</span>];</span><br><span class="line">    [<span class="atom">request</span> <span class="atom">setChampionname</span>:@<span class="string">""</span>];</span><br><span class="line"></span><br><span class="line">    <span class="name">ProtobufCGIWrap</span> * <span class="atom">cgiWrap</span> = [[<span class="name">ProtobufCGIWrap</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">    [<span class="atom">cgiWrap</span> <span class="atom">setM_pbRequest</span>:<span class="atom">request</span>];</span><br><span class="line">    [<span class="atom">cgiWrap</span> <span class="atom">setM_uiCgi</span>:<span class="number">0x412</span>];</span><br><span class="line"></span><br><span class="line">    <span class="name">MMServiceCenter</span> * <span class="atom">serviceCenter</span> = [<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>];</span><br><span class="line">    <span class="name">EventService</span> * <span class="atom">eventService</span> = [<span class="atom">serviceCenter</span> <span class="atom">getService</span>:[<span class="name">EventService</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="atom">unsigned</span> <span class="atom">int</span> <span class="atom">flag</span> = [<span class="atom">eventService</span> <span class="name">CreateProtobufEvent</span>:<span class="atom">cgiWrap</span> <span class="name">Flag</span>:<span class="number">0x5</span>];</span><br><span class="line">    <span class="atom">if</span> (<span class="atom">flag</span> != <span class="number">0x0</span>)&#123;</span><br><span class="line">        [<span class="name">CAppUtil</span> <span class="atom">addPBEventObserverListItem</span>:<span class="atom">flag</span> <span class="atom">andValue</span>:<span class="atom">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>展示微信运动好友供选择</strong>：微信中选择好友/群/公众号等等信息的时候都是使用的<strong>ContactSelectView</strong>，它内部会通过<strong>ContactsDataLogic</strong>获取所有的好友/群/公众号信息，然后实现<strong>ContactSelectViewDelegate</strong>协议的代理执行一个<code>- (_Bool)onFilterContactCandidate:(CContact *)arg1</code>操作，对传入的<strong>CContact</strong>进行筛选展示。因此，不同的控制器可以使用<strong>ContactSelectView</strong>实现选择所有好友，选择所有的聊天群等功能。</p>
<h3 id="5-非群主@所有人">5.非群主@所有人</h3><p>在群组中，只有群主才有@全体成员的功能，现在要增加非群主也可以使用@全体成员的功能。群主@全体成员就是通过修改群公告，先研究群主修改完了公告之后的发消息流程。<strong>ChatRoomInfoEditDescViewController</strong>类就是修改群公告的控制器，在点击『完成』按钮之后出来alert提示，然后可以hook<code>- (void)alertView:(id)arg1 clickedButtonAtIndex:(long long)arg2;</code>函数，使用hopper进行Decopmile 这个函数发现里面进行了如下操作：</p>
 <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGroupMgr * groupMgr = <span class="string">[[MMServiceCenter defaultCenter] getService:[CGroupMgr class]]</span>;</span><br><span class="line">NSString * usrName = self.m_chatRoomContact.m_nsUsrName;</span><br><span class="line">[groupMgr SetChatRoomDesc:usrName Desc:@<span class="string">"公告内容"</span> Flag:<span class="number">0x1</span>];</span><br></pre></td></tr></table></figure>
<p>去模拟一下这个操作，失败，究其原因应该是，只有群主的id才有权限去发送成功这个消息，并且一旦发送成功(以群主身份)，群公告也就会改变，这样也就只能作罢了。</p>
<p>另外去hook接收到的<code>群主@所有人的消息</code>的时候发现<strong>(CMessageWrap *)wrap</strong>的 <code>m_nsMsgSource</code> 属性内容为如下(这个属性是微信用来对聊天消息进行的一层xml包裹)：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">msgsource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">sequence_id</span>&gt;</span></span><br><span class="line">		656201926</span><br><span class="line">	<span class="tag">&lt;/<span class="title">sequence_id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">atuserlist</span>&gt;</span></span><br><span class="line">    	announcement@all</span><br><span class="line">	<span class="tag">&lt;/<span class="title">atuserlist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">msgsource</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要sequence_id，记录操作顺序的id，另外一个很明显的是『announcement -&gt; 群公告』，这个路看来只能再次作罢。</p>
<p>换一个研究方向，个人也是可以@个人的。这时候就是普通的发消息，但是其消息<code>wrap.m_nsMsgSource</code>为<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">msgsource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">atuserlist</span>&gt;</span></span><br><span class="line">        ***微信内部使用的用户id***</span><br><span class="line">    <span class="tag">&lt;/<span class="title">atuserlist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">msgsource</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果放入一个id就可以完成艾特改id的用户，是不是可以将当前群里面的所有人的<strong>内部用户id</strong>都放到这里面，达到@所有人的目的呢？</p>
<p>实验之后，可以的。</p>
<p>所以，下面要做的就是，获取当前群里面所有用户的<strong>内部用户id</strong>，拼成字符串，放入这个属性的xml中，而这个<strong>内部使用的用户id</strong>是<strong>CContact</strong>类的<code>m_nsUsrName</code>属性：<br> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSArray</span> *<span class="literal">result</span> = [%c(<span class="type">CContact</span>) getChatRoomMemberWithoutMyself:knToUsr];</span><br><span class="line"><span class="type">NSMutableString</span> *<span class="type">string</span> = [<span class="type">NSMutableString</span> <span class="type">string</span>];</span><br><span class="line">[<span class="literal">result</span> enumerateObjectsUsingBlock:^(<span class="type">CContact</span> * obj, <span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    [<span class="type">string</span> appendFormat:@<span class="string">",%@"</span>,[obj m_nsUsrName]];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="type">NSString</span> *sourceString = [<span class="type">string</span> substringFromIndex:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">[@<span class="string">"&lt;msgsource&gt;&lt;atuserlist&gt;%@&lt;/atuserlist&gt;&lt;/msgsource&gt;"</span> , sourceString];</span><br></pre></td></tr></table></figure></p>
<h3 id="6-消息预览">6.消息预览</h3><p>在公众号内部的网页浏览信息、看朋友圈的时候来了信息，需要退返回主页面，然后如果要回到公众号、朋友圈的位置就要一步步的返回回去。因此，对要跳转到聊天室的时候做一个记录浏览的记录，就可以在消息和网页浏览之间切换了。</p>
<p>需要hook到收到聊天消息的方法，自然是哪哪儿都有他的<code>-[CMessageMgr AsyncOnAddMsg:MsgWrap:]</code>了，然后在这里记录消息内容，使用通知的方法将事件广播出去。在需要的界面通过添加通知，对通知中的内容进行展示，提供一个视图，点击的时候可以调抓到对应的聊天室，跳转之前需要记录当前控制器的调用栈。</p>
<p>公众号阅读控制器为：<strong>MMWebViewController</strong>，朋友圈控制器为： <strong>WCTimeLineViewController</strong>，所以可以hook这两个控制器的<code>-viewDidLoad</code>方法，添加通知。</p>
<p>更加极端的是为所有控制器的父类<strong>MMUIViewController</strong>添加通知，但是在聊天室控制器<strong>BaseMsgContentViewController</strong>中移除通知，这样就可以达到为所有非聊天室界面提供消息预览的功能了。</p>
<p>这个思路是参考<a href="http://corbinchen.com/2016/02/26/我是如何利用Xcode调试开发微信消息预览插件的/" target="_blank" rel="external">这篇博文</a>理出来的，我只不过是改进了一些东西。但是这个思路中有一个bug：从公众号网页点击消息预览回到聊天室，再从聊天室回到公众号网页，然后公众号网页一步步pop到根视图控制器，再进入聊天室点击回到公众号网页按钮，会发现整个网页什么都没有，而且公众号聊天界面是黑的。目前还没有想出来解决办法。</p>
<p><a href="http://corbinchen.com/2016/02/26/我是如何利用Xcode调试开发微信消息预览插件的/" target="_blank" rel="external">参考文章：我是如何利用Xcode调试开发微信消息预览插件的</a></p>
<h3 id="7-自动回复">7.自动回复</h3><p>自动回复说白了，就是本地保存一个列表，列表中的每一个匹配规则类似于一个key-value，key是进行匹配的规则，使用正则匹配，value是匹配成功之后的回复消息。然后hook<code>-[CMessageMgr AsyncOnAddMsg:MsgWrap:]</code>判断接收到的消息内容去匹配本地列表，匹配成功了就返回对应要自动回复的内容。进行匹配的时候一定要有尽量多的判断条件，否则会引起<code>自己发给自己然后循环往复的自动回复</code>的bug。</p>
<p>为了避免上面提到的bug发生，除了在hook接收消息的时候严谨的判断，在设置匹配规则的时候也要尽可能的避免<code>.*</code>这种任何文本都可以匹配的正则表达式。另外为了误操作，仅支持单聊的时候对方发给自己消息的时候进行匹配，启动自动回复。</p>
<img src="/2017/09/11/hook-wechat/wechat_autoreply.png" alt="autoreply" title="autoreply">
<h3 id="8-调试工具">8.调试工具</h3><p>在看到<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/CocoaPods" target="_blank" rel="external">wiki</a>的时候发现支持pods，例子就是调试工具<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">FLEX</a>，本来是打算使用系统提供的调试工具来实现调试功能的，但是，很明显，在release模式下，调试工具是没有用的，一直显示不出来。</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/</span></span><br><span class="line"></span><br><span class="line">Class debugCls = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIDebuggingInformationOverlay"</span>);</span><br><span class="line">[debugCls performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"prepareDebuggingOverlay"</span>)];</span><br></pre></td></tr></table></figure>
<p>按照wiki中的办法使用cocoaPods进行添加FLEX到项目中，然后就可以在微信中使用FLEX进行调试，很方便，并且还是开源的工具。</p>
<h3 id="9-为聊天面板增加插件">9.为聊天面板增加插件</h3><p>插件面板、输入框、表情等等都是加在<strong>SelectAttachmentViewController</strong>控制器中的，而<strong>SelectAttachmentViewController</strong>的view加到<strong>MMInputToolView</strong>上供显示、操作的,他们之间的事件回调使用的是<strong>SelectAttachmentViewControllerDelegate</strong>协议。<strong>MMInputToolView</strong>是加在聊天室控制器中的视图，他们之间的事件回调是使用的<strong>MMInputToolViewDelegate</strong>协议。</p>
<p><strong>SelectAttachmentViewController</strong>的<code>_arrAttachementObjectItems</code>变量是用来存储插件对象的，存储的对象为<strong>AttachementObjectItem</strong>类，这个对象中有目前我们自定义一个插件需要的所有：图片、文字、点击回调SEL：<br> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">AttachementObjectItem </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *nsTitle; <span class="comment">// @synthesize nsTitle=_nsTitle;</span></span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) UIImage *oImage; <span class="comment">// @synthesize oImage=_oImage;</span></span><br><span class="line"><span class="variable">@property</span>(nonatomic) SEL selAction; <span class="comment">// @synthesize selAction=_selAction;</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>结合以上可以理一下插件的事件响应顺序为：</p>
<ul>
<li>为<code>_arrAttachementObjectItems</code>数组添加的插件类中的selAction是插件在点击的时候</li>
<li>去询问控制器(SelectAttachmentViewController)的代理 (MMInputToolView)</li>
<li>然后代理(MMInputToolView)实现协议(SelectAttachmentViewControllerDelegate)中的方法</li>
<li>而且代理(MMInputToolView)自己也有他的代理，也就是聊天室控制器(BaseMsgContentViewController)</li>
<li>MMInputToolView再将事件传递给聊天控制器去实现插件中的操作，到此就完成了一个插件的事件调用链</li>
</ul>
<p>查看头文件发现<strong>SelectAttachmentViewController</strong>是在<code>-initObjectItem</code>方法中初始化添加插件对象到<code>_arrAttachementObjectItems</code>中的，所以，就从hook这个函数开始按照上面的逻辑添加插件。</p>
<p>那么下面就简单了，按照上面的逻辑</p>
<ol>
<li>hook <code>-initObjectItem</code>函数为<code>_arrAttachementObjectItems</code>数组添加一个自定义的插件对象</li>
<li>为<strong>MMInputToolView</strong>添加一个 <em>自定义插件中的需要响应的方法</em></li>
<li>为<strong>BaseMsgContentViewController</strong>添加一个<strong>MMInputToolView</strong>要传递过来的插件响应方法的方法</li>
</ol>
<img src="/2017/09/11/hook-wechat/wechat_attachment.png" alt="attachment" title="attachment">
<p>完成以上之后发现，群聊和单聊都添加了一个插件，很明显这不是想要的结果，需要想办法不为单聊添加自定义插件。那么对比一下群聊和单聊插件面板的差别可以发现：群聊可以群视频，群聊不可以转账，单聊只可以单个视频。使用FLEX查找发现不同的面板中有好几个属性是不一样的，不过其中一个<code>@property(nonatomic) _Bool allowMultiTalk;</code>属性的不同是很能区别出来是群聊还是单聊。实验一下，确实可以区分出来。</p>
<p>通过这个插件，可以为上面的<strong>@所有人</strong>功能在聊天室内添加更便捷的操作入口。</p>
<h3 id="10-表情相关">10.表情相关</h3><p>表情相关是直接使用的这个仓库，里面有可以直接从web页面将图片(静态图、gif图)保存为表情，并且修改了表情最大限制尺寸。</p>
<p><a href="https://github.com/Mainstayz/WeChatWebEmoticon" target="_blank" rel="external">Github：一键保存为表情，无视微信表情大小的限制</a></p>
<h3 id="11-将已发送的文字朋友圈在私密/公开之间切换">11.将已发送的文字朋友圈在私密/公开之间切换</h3><p>朋友圈的图片可以自由的进行『私密』-&gt;『公开』切换，但是文字却没有这个功能，一旦在是发送文字朋友圈的时候选择隐私，那么就一直是隐私，不可以再改为公开，相反，选择公开，就不可以再改为隐私。如果图片版可以自由切换，那么同为朋友圈的文字版应该也可以进行切换的。</p>
<p>首先，要找到图片版和文字版的区别和共同点。使用FLEX发现，图片和文字都有使用的<strong>WCDataItem</strong>来表示一条，不过图片中是又包了一层，使用<strong>WCMediaItemWrap</strong>来表示，具体需要的东西如下：<br> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">WCDataItem </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) NSString *username;</span><br><span class="line"><span class="variable">@property</span>(nonatomic) _Bool isPrivate;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">WCMediaItemWrap </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(nonatomic) unsigned int index;</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) WCDataItem *parent;</span><br><span class="line"><span class="variable">@property</span>(retain, nonatomic) WCMediaItem *mediaItem;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p><strong>WCPhotoMutipleImageViewController</strong>是图片版本的控制器，里面的actionSheet回调里面有进行『私密/公开』的操作，hopper他的<code>- (void)actionSheet:(WCActionSheet *)arg1 clickedButtonAtIndex:(long long)arg2;</code>方法会发现，分别调用如下的方法:<br> <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 设为公开</span><br><span class="line">- (<span class="atom">void</span>)<span class="atom">onMakePublic</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="name">WCMediaItemWrap</span> * <span class="atom">mediaItemWrap</span> = [<span class="atom">self</span> <span class="atom">getMediaItemWrapAnywayAt</span>:<span class="atom">self</span>.<span class="atom">m_iCurrentPage</span>];</span><br><span class="line">    <span class="name">WCFacade</span> * <span class="atom">facade</span> = [[<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">getService</span>:[<span class="name">WCFacade</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="name">WCDataItem</span> * <span class="atom">parent</span> = <span class="atom">mediaItemWrap</span>.<span class="atom">parent</span>;</span><br><span class="line">    [<span class="atom">facade</span> <span class="atom">setDataItemPublic</span>:<span class="atom">parent</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设为隐私</span><br><span class="line">- (<span class="atom">void</span>)<span class="atom">onMakePrivate</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="name">WCMediaItemWrap</span> * <span class="atom">mediaItemWrap</span> = [<span class="atom">self</span> <span class="atom">getMediaItemWrapAnywayAt</span>:<span class="atom">self</span>.<span class="atom">m_iCurrentPage</span>];</span><br><span class="line">    <span class="name">WCFacade</span> * <span class="atom">facade</span> = [[<span class="name">MMServiceCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">getService</span>:[<span class="name">WCFacade</span> <span class="atom">class</span>]];</span><br><span class="line">    <span class="name">WCDataItem</span> * <span class="atom">parent</span> = <span class="atom">mediaItemWrap</span>.<span class="atom">parent</span>;</span><br><span class="line">    [<span class="atom">facade</span> <span class="atom">setDataItemPrivate</span>:<span class="atom">parent</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就是里面的<strong>WCFacade</strong>类的<code>-setDataItemPrivate:(WCDataItem *)arg1</code>和<code>-setDataItemPublic:(WCDataItem *)arg1</code>这两个方法，而文字版本就是使用<strong>WCDataItem</strong>来表示的，所以，按道理传入文字版的<strong>WCDataItem</strong>实例就可以进行私密/公开的切换了。</p>
<p>结合以上<strong>WCFacade</strong>头文件中有价值的信息为：<br> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">WCFacade :</span> NSObject</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setDataItemPublic:</span>(WCDataItem *)arg1;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setDataItemPrivate:</span>(WCDataItem *)arg1;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure></p>
<p>接下来就可以在文字朋友圈详情界面进行添加操作入口。<strong>WCCommentDetailViewControllerFB</strong>就是文字版本详情控制器，他有一个属性<code>@property(retain, nonatomic) WCDataItem *dataItem;</code>代表当前的朋友圈数据，结合图片朋友圈隐私/公开的操作逻辑，可以使用这个属性来做私密/公开操作。</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文字朋友圈设为公开</span></span><br><span class="line">- (<span class="keyword">void</span>)_textDetailOnMakePublic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[self startLoadingBlocked];</span></span><br><span class="line">    W<span class="built_in">CFacade</span> * facade = [[MMServiceCenter defaultCenter] getService:[W<span class="built_in">CFacade</span> class]];</span><br><span class="line">    [facade setDataItemPublic:<span class="keyword">self</span><span class="variable">.dataItem</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文字朋友圈设为隐私</span></span><br><span class="line">- (<span class="keyword">void</span>)_textDetailOnMakePrivate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[self startLoadingBlocked];</span></span><br><span class="line">    W<span class="built_in">CFacade</span> * facade = [[MMServiceCenter defaultCenter] getService:[W<span class="built_in">CFacade</span> class]];</span><br><span class="line">    [facade setDataItemPrivate:<span class="keyword">self</span><span class="variable">.dataItem</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加以上的方法，经测试，发现是可以把文字版本朋友圈进行私密/公开的转换。</p>
<h3 id="12-聊天机器人">12.聊天机器人</h3><p>是自动回复的升级版，todo</p>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/学习/">学习</a>, <a class="tag-link" href="/tags/微信/">微信</a>, <a class="tag-link" href="/tags/逆向/">逆向</a></div></article></div><div class="post-nav"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/2017/08/05/sketch/" class="next-post">使用Sketch进行设计学习</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>