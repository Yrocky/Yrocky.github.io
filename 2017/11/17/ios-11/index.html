<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">关于自动布局下iPhone X以及iOS11的适配</h1><div class="post-info">11月 17日 2017</div><div class="post-entry"><p>自从提供了<strong>Auto Layout</strong>之后，官方文档中就建议开发者尽量的在布局中使用自动布局技术，虽然使用frame布局可以应付一些屏幕尺寸不是很多的设备，但是遇到iPad中可以进行多界面操作、iPhone X安全区内布局这样的迭代出来的适配问题，以前的frame布局会越来越不实用，对界面的掌控力度越来越弱，因此下面所有讨论都是基于使用Auto Layout布局而不是frame布局。</p>
<img src="/2017/11/17/ios-11/ios_11_safe_area.png" alt="title" title="title">
<a id="more"></a>
<h3 id="1-安全区域">1.安全区域</h3><h4 id="危险区：传感器区域">危险区：传感器区域</h4><p>在新机型iPhone X中由于全面屏的特性，顶部和底部分别有两个特别的传感器，顶部是<strong>一个凹形</strong>，底部则是<strong>一个短矩形</strong>。Apple的指导规则是，所有的控件都要在<code>safeArea</code>内，如果有可能，尽量在safeAreaMargin内以增加横屏下的控件的误操作间距。比如下面这个在<strong>标签管理界面</strong>的底部操作按钮就应该这样进行适配：</p>
<img src="/2017/11/17/ios-11/iOS_11_img_bottom.png" alt="title" title="title">
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[finishButton mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">&#123;</span><br><span class="line">    make.left.and.right.mas_equalTo<span class="list">(<span class="keyword">self.view</span>)</span><span class="comment">;</span></span><br><span class="line">    make.height.mas_equalTo<span class="list">(<span class="number">49</span>)</span><span class="comment">;</span></span><br><span class="line">    if <span class="list">(@available<span class="list">(<span class="keyword">iOS</span> <span class="number">11.0</span>, *)</span>)</span> <span class="collection">&#123;</span><br><span class="line">        make.bottom.mas_equalTo<span class="list">(<span class="keyword">self.view.mas_safeAreaLayoutGuideBottom</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span> else <span class="collection">&#123;</span><br><span class="line">        make.bottom.mas_equalTo<span class="list">(<span class="keyword">self.view.mas_bottom</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span></span><br><span class="line">  // 或者直接使用viewController的topLayoutGuide、bottomLayoutMargin，</span><br><span class="line">  // 不过这个属性在iOS11已经被废弃了，推荐使用UIView的安全区域</span><br><span class="line">//  make.bottom.mas_equalTo<span class="list">(<span class="keyword">self.mas_bottomLayoutGuideTop</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>同理，顶部的适配也是类似的，只不过是bottom和top的区别而已。</p>
<h4 id="安全区域下的Statusbar和Tabbar">安全区域下的Statusbar和Tabbar</h4><p>由于传感器的存在，iPhone X机型上会有一些危险区域，这些区域内部是不允许有任何app内部的可操作控件，相应的为了适应safeArea，状态栏和Tabbar的高度在iPhone X上也有所改变。</p>
<img src="/2017/11/17/ios-11/ios_11_status_bar.png" alt="title" title="title">
<p>如图可以看出来，在iPhone X机型下，状态栏增加了44px (@2x)，Tabbe增加了34px (@2x)。</p>
<h4 id="UIView的安全区域">UIView的安全区域</h4><p>自定义的视图添加到控制器中，在iOS11以前由于没有安全区域的概念，所以，一般的布局没有问题，但是到了iPhone X中，显示会有一些偏差，具体就是：上面太靠上、下面太贴下。</p>
<img src="/2017/11/17/ios-11/ios_11_living_customView.png" alt="title" title="title">
<h4 id="全屏显示的界面">全屏显示的界面</h4><p><img src="https://github.com/Yrocky/Yrocky.github.io/blob/master/2017/11/17/ios-11/ios_11_full_size.png?raw=true" align="left"></p>
<p>我们的项目中有许多地方是需要全屏显示。针对于全屏显示的视图，其布局可以使用frame根据屏幕尺寸的大小进行设置rect；也可以使用自动布局进行布局，但是，约束就不再跟safe area有关了，可以直接根据<strong>superView</strong>的<code>top</code>、<code>bottom</code>来设置约束。比如右边的这个侧滑出来的效果，整个模糊视图是添加在控制器上的，然后上面的控件添加到这个全屏显示的视图上。</p>
<p>虽然对于全屏视图不需要使用safe area，但是，其子视图则需要使用safe area来适配iPhone X机型。具体适配可以参考上面适配底部传感器中的方式：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[self.bottomSubview mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">&#123;</span><br><span class="line">    make.left.and.right.mas_equalTo<span class="list">(<span class="keyword">superView</span>)</span><span class="comment">;</span></span><br><span class="line">    make.height.mas_equalTo<span class="list">(<span class="number">49</span>)</span><span class="comment">;</span></span><br><span class="line">    if <span class="list">(@available<span class="list">(<span class="keyword">iOS</span> <span class="number">11.0</span>, *)</span>)</span> <span class="collection">&#123;</span><br><span class="line">        make.bottom.mas_equalTo<span class="list">(<span class="keyword">superView.mas_safeAreaLayoutGuideBottom</span>)</span>.mas_offset<span class="list">(<span class="keyword">-20</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span> else <span class="collection">&#123;</span><br><span class="line">        make.bottom.mas_equalTo<span class="list">(<span class="keyword">superView.mas_bottom</span>)</span>.mas_offset<span class="list">(<span class="keyword">-20</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="半屏幕显示的界面">半屏幕显示的界面</h4><p><img src="https://github.com/Yrocky/Yrocky.github.io/blob/master/2017/11/17/ios-11/ios_11_popup_view.png?raw=true" align="right"></p>
<p>项目中比较多的是直播间从底部弹出一些视图，这些视图有的为展示类型，有的为可操作类型，展示类型中又分为表视图可滚动以及标签静态展示。对于表视图，Apple的文档中说可以设置底部紧贴父视图的底部，UIKit会为底部传感器遮挡的部分流出来间距，而如果是标签或者按钮之类的非滚动控件，则需要开发人员自行进行安全区域的适配。</p>
<p>这部分我的设计建议是对这些半屏可弹出视图进行重新设计：</p>
<ul>
<li><p>对于<code>弹出视图</code>，让他们都全屏显示</p>
</li>
<li><p>然后添加<code>遮罩视图</code>提供毛玻璃、无颜色、透明黑色等显示效果，并且具备点击隐藏的响应事件</p>
</li>
<li><p>内部添加需要展示的<code>内容视图</code>，根据需要展示的具体内容撑起整个<code>内容视图</code>。</p>
</li>
</ul>
<p>因为有的具体内容需要避开底部的传感器，因此会有不同版本之间的适配。或者不使用<code>遮罩视图</code>，让<code>弹出视图</code>自己成为<code>遮罩视图</code>。如右所示：</p>
<p>对弹出视图做约束：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BottomFollowView </span>* followView = [<span class="keyword">BottomFollowView </span>followView]<span class="comment">;</span></span><br><span class="line">[<span class="keyword">self.view </span><span class="keyword">addSubview:followView];</span><br><span class="line"></span>[followView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.edges.mas_equalTo(<span class="keyword">self.view);</span><br><span class="line"></span>&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>依照上面的设计规则，对内容视图做约束：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[_contentView mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">&#123;</span><br><span class="line">    make.left.right.mas_equalTo<span class="list">(<span class="keyword">self</span>)</span><span class="comment">;</span></span><br><span class="line">    make.bottom.mas_equalTo<span class="list">(<span class="keyword">self</span>)</span><span class="comment">;</span></span><br><span class="line">    make.top.mas_equalTo<span class="list">(<span class="keyword">_followButton.mas_top</span>)</span>.mas_offset<span class="list">(<span class="keyword">-20</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="collection">[_followButton mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">    CGFloat margin = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">    make.size.mas_equalTo<span class="list">(<span class="keyword">CGSizeMake</span><span class="list">(<span class="number">120</span>, <span class="number">40</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">    make.centerX.mas_equalTo<span class="list">(<span class="keyword">_contentView</span>)</span><span class="comment">;</span></span><br><span class="line">    if <span class="list">(@available<span class="list">(<span class="keyword">iOS</span> <span class="number">11.0</span>, *)</span>)</span> <span class="collection">&#123;</span><br><span class="line">        make.bottom.mas_equalTo<span class="list">(<span class="keyword">_contentView.mas_safeAreaLayoutGuideBottom</span>)</span>.mas_offset<span class="list">(<span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span> else <span class="collection">&#123;</span><br><span class="line">        make.bottom.mas_equalTo<span class="list">(<span class="keyword">_contentView.mas_bottom</span>)</span>.mas_offset<span class="list">(<span class="keyword">-margin</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="Xib中的安全区域">Xib中的安全区域</h4><p>难保一些界面使用xib进行构建，这些界面中有部分需要适配iPhone X，就需要用到安全区域。在xib中打开安全区域的办法很简单，由于这个是iOS 11中添加的，所以要求<strong>Xcode版本至少9.0以上</strong>，如图：</p>
<img src="/2017/11/17/ios-11/ios_11_xib_safe_area.png" alt="title" title="title">
<p>打开使用<code>safeAreaLayoutGuide</code>之后，子视图就可以根据安全区域来进行设置约束了。在设置约束的时候不再是根据superView来进行布局，而是根据<strong>safe area</strong>：</p>
<img src="/2017/11/17/ios-11/ios_11_xib_display_safe_area.png" alt="title" title="title">
<p>这样设置之后，实测在低版本(iOS 11以下)中，也不会出现系统不匹配运行崩溃的问题，应该是UIKit内部做了适配。但是如果项目最低版本为iOS 8.0，则不可以在xib中使用safe  area功能。</p>
<h3 id="2-导航栏">2.导航栏</h3><p>在iOS11之后新增了一个<code>lagreTitle</code>属性，就是大标题，默认是不开启的，也可以选择在那一个控制器中开启，由于我们的项目中暂时没有用到大标题，所以没有适配需求。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> UINavigationBar</span><br><span class="line"><span class="comment">/// 当设置为YES的时候，导航栏支持使用大标题，对于特殊的不需要显示大标题的控制器，</span></span><br><span class="line"><span class="comment">/// 可以通过设置UINavigationItem.largeTitleDisplayMode的值来决定 。默认是 NO.</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, readwrite, assign) BOOL prefersLargeTitles;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> UINavigationItem</span><br><span class="line"><span class="comment">/// 当 UINavigationBar.prefersLargeTitles=YES的时候来决定当前控制器的大标题如何显示。</span></span><br><span class="line"><span class="comment">/// 如果 prefersLargeTitles=NO的时候，大标题无效。默认值是 Automatic</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, readwrite, assign) UINavigationItemLargeTitleDisplayMode largeTitleDisplayMode;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>对于返回按钮，项目中导航栏的返回效果是一个返回箭头，没有文字。在iOS10之前使用自定义的返回按钮是没有问题的，不过到了iOS11之后，返回按钮就是这个样子，有一个向下大约10px的位移。不过在新建一个工程之后，却没有这样的情况发生，有可能是老版本遗留下的问题，不过这都可以使用下面的自定义返回按钮进行解决。</p>
<img src="/2017/11/17/ios-11/iOS_11_navi.png" alt="title" title="title">
<p>目前有两种不同系统下的四种情况：</p>
<h4 id="使用系统提供的返回按钮">使用系统提供的返回按钮</h4><img src="/2017/11/17/ios-11/ios_11_system_back.png" alt="title" title="title">
<img src="/2017/11/17/ios-11/ios_10_system_back.png" alt="title" title="title">
<p>可以看出来，在iOS11以前，系统只是使用了两个简单的类：<strong>UINavigationItemButtonView</strong>、<strong>_UINavigationBarBackIndicatorView</strong>来展示返回按钮和前一个界面的<code>title</code>。而到了iOS11，则使用了更多的类来进行返回按钮的组装，应该是由于在iOS 11之后，导航栏也支持<strong>自动布局</strong>了，简单的两个类不能够适用于多种场景，增加了一些容器类：<strong>_UINavigationBarContentView</strong>、<strong>_UIButtonBarStackView</strong>等。</p>
<h4 id="使用自定义的返回按钮">使用自定义的返回按钮</h4><img src="/2017/11/17/ios-11/ios_11_custom_back.png" alt="title" title="title">
<img src="/2017/11/17/ios-11/ios_10_custom_back.png" alt="title" title="title">
<p>而如果使用自定义返回按钮，在iOS11系统下，系统提供了一些<strong>StackView</strong>来实现对自定义按钮的自动布局约束，具体为，<code>navigationBar</code>会添加在<strong>_UIButtonBarStackView</strong>上面，而<strong>_UIButtonBarStackView</strong>则添加在<strong>_UINavigationBarContentView</strong>上面。</p>
<h4 id="title和titleView">title和titleView</h4><p>导航栏中的<code>title</code>和<code>titleView</code>在iOS11 以后也发生了变化。</p>
<img src="/2017/11/17/ios-11/iOS_11_UINavigationBar.png" alt="title" title="title">
<p>由于我们不需要自定义<code>titleView</code>，因此这部分没有什么适配问题。</p>
<h3 id="3-UIScrollView">3.UIScrollView</h3><p>iOS11中废弃了<code>automaticallyAdjustsScrollViewInsets</code>，取而代之的是<strong style="color:#4288E6">contentInsetAdjustmentBehavior</strong>属性和<strong style="color:#4288E6">adjustedContentInset</strong>属性决定<strong>UIScrollView</strong>与边缘的距离。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewContrller</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> automaticallyAdjustsScrollViewInsets API_DEPRE<span class="built_in">CATED_WITH_REPLACEMENT</span>(<span class="string">"Use UIScrollView's contentInsetAdjustmentBehavior instead"</span>, ios(<span class="number">7.0</span>,<span class="number">11.0</span>),tvos(<span class="number">7.0</span>,<span class="number">11.0</span>)); <span class="comment">// Defaults to YES</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIScrollView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当contentInsetAdjustmentBehavior允许时，UIScrollView可以合并</span><br><span class="line"> safeAreaInsets放入adjustedContentInset中。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIEdgeInsets</span> adjustedContentInset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置 adjustedContentInset</span><br><span class="line">默认是 UIScrollViewContentInsetAdjustmentAutomatic.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UIScrollViewContentInsetAdjustmentBehavior</span> contentInsetAdjustmentBehavior API_<span class="built_in">AVAILABLE</span>(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIScrollViewContentInsetAdjustmentBehavior</span>) &#123;</span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentAutomatic</span>, <span class="comment">// 类似于.scrollableAxes，但是为了向后兼容性，当滚动视图由视图控制器拥有时，也会调整顶部和底部contentInset，在导航控制器中自动调用ScrollViewInsets = YES，而不管滚动视图是否可滚动</span></span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentScrollableAxes</span>, <span class="comment">// 可滚动轴的边缘被调整（即，contentSize.width / height&gt; frame.size.width / height或alwaysBounceHorizontal / Vertical = YES）</span></span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>, <span class="comment">// contentInset 不适应内边距</span></span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentAlways</span>, <span class="comment">// contentInset 永远会适应scrollView的safeAreaInsets</span></span><br><span class="line">&#125; API_<span class="built_in">AVAILABLE</span>(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br></pre></td></tr></table></figure>
<h4 id="UITableView">UITableView</h4><p><strong>UITableView</strong>在iOS 11中默认启用<code>Self-Sizing</code>。在iOS8引入<code>Self-Sizing</code> 之后，我们可以通过实现<strong>estimatedRowHeight</strong>相关的属性来展示动态的内容，实现了<code>estimatedRowHeight</code>属性后，得到的初始<code>contentSize</code>是个估算值，是通过(<strong>estimatedRowHeight</strong> <code>x</code> <strong>cell的个数</strong>)得到的，并不是最终的<code>contentSize</code>，<code>tableView不会一次性计算所有的cell的高度了</code>，只会计算当前屏幕能够显示的cell个数再加上几个，滑动时，tableView不停地得到新的cell，更新自己的contenSize，在滑到最后的时候，会得到正确的contenSize。如果底部区域不存在可交互的固定组件，那么tableView需要延伸到屏幕底部，而不是安全区域以内，UIKit会为滚动视图提供一个安全的contentOffset。</p>
<img src="/2017/11/17/ios-11/ios_11_tableView_self_sizing.png" alt="title" title="title">
<p>由于我们的项目中没有使用<code>self-sizing</code>，基本上都是固定或者计算动态高度，所以需要关闭默认开启的<code>Self-Sizing</code>：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">self</span>.<span class="built_in">table</span>View.estimatedRowHeight = <span class="number">0</span>;</span><br><span class="line"><span class="literal">self</span>.<span class="built_in">table</span>View.estimatedSectionHeaderHeight = <span class="number">0</span>;</span><br><span class="line"><span class="literal">self</span>.<span class="built_in">table</span>View.estimatedSectionFooterHeight = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>UITableView</strong>除了在iOS11下自动开启了<code>Self-Sizing</code>，还对<strong>UITableViewCell</strong>的<strong>contentView</strong>进行了安全区域的修改。在竖屏情况下是不会有影响的，在横屏下，由于左右的传感器区域，UIKit会将contentView内嵌入安全区域内，如果不需要内嵌到安全区域，可以手动关闭这个特性，使用<strong>UITableView</strong>的<code>insetsContentViewsToSafeArea</code>属性来进行控制：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> insetsContentViewsToSafeArea API_<span class="built_in">AVAILABLE</span>(ios(<span class="number">11.0</span>), tvos(<span class="number">11.0</span>)); <span class="comment">// default value is YES。</span></span><br></pre></td></tr></table></figure>
<img src="/2017/11/17/ios-11/ios_11_table_view_content_view.png" alt="title" title="title">
<h3 id="4-自动布局">4.自动布局</h3><p>如果使用<strong>Frame</strong>设置用户界面，必须计算视图层次结构中每个视图的大小和位置，然后，当发生变化(比如旋转屏幕、iPad多屏幕任务等)，则必须重新计算所有受影响的视图的位置。由于必须自己管理所有更改，因此，设计一个简单的用户界面需要花费大量的精力进行设计，调试和维护，创建一个真正的自适应用户界面增加了一个数量级的困难。</p>
<p><strong>自动布局(Auto Layout)</strong>使用一系列<code>约束</code>来定义用户界面。约束通常代表两个视图之间的关系。自动布局然后基于这些约束来计算每个视图的大小和位置。这产生了动态响应内部和外部变化的布局效果。</p>
<h4 id="一个约束的意义">一个约束的意义</h4><p>视图层次结构的布局被定义为一系列线性方程式。每个约束表示一个单一的等式。设置约束的目的是书写一系列只有一个可能解决方案的方程。</p>
<img src="/2017/11/17/ios-11/ios_11_layout.png" alt="title" title="title">
<p><strong>Auto Layout</strong>经常提供多种方法来解决同样的问题。理想情况下，应该选择最清楚地描述设置约束的方案。但是，不同的开发人员会有不同的设置约束习惯。官方文档推荐使用以下经验法则：</p>
<ul>
<li>整数乘法器比分数乘法器更容易理解</li>
<li>正常数比负常数更好</li>
<li>设置约束的时候最好有一个固定的顺序：首尾，上下</li>
</ul>
<h4 id="优先级">优先级</h4><p>您也可以创建可选约束，所有约束条件的优先级都在1到1000之间。优先级为1000的约束条件是必需的，所有其他限制是可选的。</p>
<p>设计约束的解决方案时，自动布局尝试按优先级顺序从最高到最低来满足所有约束条件。如果它不能满足可选约束，则跳过该约束并继续到下一个约束。</p>
<p>不要觉得有义务使用全部1000个优先级值。事实上，优先级应该围绕系统定义的</p>
<ul>
<li><code>低（250）</code></li>
<li><code>中（500）</code></li>
<li><code>高（750）</code></li>
<li><code>必需（1000）</code></li>
</ul>
<p>优先级进行。可能需要制定高于或低于这些值一个或两个点的约束，以解决约束的时候出现的多重约束问题。如果超出这个范围，你可能想要重新检查布局的逻辑。</p>
<h4 id="边距">边距</h4><p>在使用Xib创建视图并使用自动布局的时候，子视图相对于父视图会有一个间距，兄弟视图之间也有一个间距，这个间距有时候并不是我们想要的。</p>
<img src="/2017/11/17/ios-11/ios_11_layout_margin.png" alt="title" title="title">
<h4 id="NSLayoutConstraint"><a href="https://developer.apple.com/documentation/uikit/nslayoutconstraint" target="_blank" rel="external">NSLayoutConstraint</a></h4><p><strong>NSLayoutConstraint</strong>就是上面对一个约束的抽象类，可以根据这个类的实例进行两个视图的约束设置，遵循</p>
<blockquote>
<p>item1.attribute1 = multiplier × item2.attribute2 + constant</p>
</blockquote>
<p>公式。</p>
<p>另外，约束不限于平等关系。它们也可以使用<code>大于或等于（&gt; =）</code>或<code>小于或等于（&lt;=）</code>来描述两个属性之间的关系。制约因素也有优先级在1和1,000之间。</p>
<p>这种是Auto Layout框架下最基础的约束设置，但也是书写起来最麻烦的约束设置。</p>
<h4 id="NSLayoutAnchor"><a href="https://developer.apple.com/documentation/uikit/nslayoutanchor" target="_blank" rel="external">NSLayoutAnchor</a></h4><p>上面的布局方程式简单的介绍了一个约束其实是什么，<strong>NSLayoutAnchor</strong>这个类就是可以简化布局方程式的一个工厂类，因此他可以极大的简化创建NSLayoutConstraint的过程。</p>
<blockquote>
<p><code>UIView</code>不提供布局边距属性的锚定属性。相反，有一个<a href="https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide" target="_blank" rel="external"><code>layoutMarginsGuide</code></a>属性提供了一个<code>UILayoutGuide</code>的对象代表这些边距，使用layoutGuide的锚点属性来创建您的约束。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSLayoutConstraint 创建约束</span></span><br><span class="line">[<span class="built_in">NSLayoutConstraint</span></span><br><span class="line"> constraintWithItem:subview</span><br><span class="line"> attribute:<span class="built_in">NSLayoutAttributeLeading</span></span><br><span class="line"> relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line"> toItem:<span class="keyword">self</span><span class="variable">.view</span></span><br><span class="line"> attribute:<span class="built_in">NSLayoutAttributeLeadingMargin</span></span><br><span class="line"> multiplier:<span class="number">1.0</span></span><br><span class="line"> constant:<span class="number">0.0</span>]<span class="variable">.active</span> = <span class="literal">YES</span>;</span><br><span class="line"> </span><br><span class="line">[<span class="built_in">NSLayoutConstraint</span></span><br><span class="line"> constraintWithItem:subview</span><br><span class="line"> attribute:<span class="built_in">NSLayoutAttributeTrailing</span></span><br><span class="line"> relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line"> toItem:<span class="keyword">self</span><span class="variable">.view</span></span><br><span class="line"> attribute:<span class="built_in">NSLayoutAttributeTrailingMargin</span></span><br><span class="line"> multiplier:<span class="number">1.0</span></span><br><span class="line"> constant:<span class="number">0.0</span>]<span class="variable">.active</span> = <span class="literal">YES</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Layout Anchors 创建同样的约束</span></span><br><span class="line"><span class="built_in">UILayoutGuide</span> *margin = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layoutMarginsGuide</span>;</span><br><span class="line">subView<span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">[subview<span class="variable">.leadingAnchor</span> constraintEqualToAnchor:margin<span class="variable">.leadingAnchor</span>]<span class="variable">.active</span> = <span class="literal">YES</span>;</span><br><span class="line">[subview<span class="variable">.trailingAnchor</span> constraintEqualToAnchor:margin<span class="variable">.trailingAnchor</span>]<span class="variable">.active</span> = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<p>但是在使用NSLayoutAnchor的时候，需要注意一点，记得将视图的<code>translatesAutoresizingMaskIntoConstraints</code>属性设置为<strong>NO</strong>，意思是视图使用autolayout。</p>
<blockquote>
<p>默认情况下，视图上的自动调整掩码会产生完全确定的约束视图的位置。这允许自动布局系统跟踪其视图的帧布局是手动控制的（例如通过-setFrame：）。<br>当您选择通过添加自己的约束来使用自动布局来定位视图时，您必须将此属性设置为NO。 IB将为你做这个。</p>
<p><strong>@property(nonatomic) BOOL translatesAutoresizingMaskIntoConstraints NS_AVAILABLE_IOS(6_0); // Default YES</strong></p>
</blockquote>
<p>虽然文档上说的UIView不会提供布局的边距锚点，可以通过<code>layoutMarginGuide</code>来获取，但是通过这个属性可以看出来，这样的布局是有一个<strong>margin</strong>的，默认是20。如果不使用<code>layoutMarginGuide</code>，直接使用<code>self.view.leftAnchor</code>也是可以进行锚点布局，的这时候就不会有一个20的间距了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UILayoutGuide</span> *margin = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layoutMarginsGuide</span>;</span><br><span class="line">[redView_layoutAnchor<span class="variable">.leftAnchor</span> constraintEqualToAnchor:margin<span class="variable">.leftAnchor</span> constant:<span class="number">0</span>]<span class="variable">.active</span> = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个设置的效果是一样的，都是距离父视图右边局 20，区别就是没有使用 layoutMarginsGuide 属性</span></span><br><span class="line">[redView_layoutAnchor<span class="variable">.leftAnchor</span> constraintEqualToAnchor:<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.leftAnchor</span> constant:<span class="number">20</span>]<span class="variable">.active</span> = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<h4 id="UILayoutGuide"><a href="https://developer.apple.com/documentation/uikit/uilayoutguide" target="_blank" rel="external">UILayoutGuide</a></h4><p>这是iOS9.0以后新增的类，用来对使用Auto Layout布局的时候提供虚拟占位，不会渲染到视图层级结构中。</p>
<p>这个类设计的巧妙的地方就在于他不会渲染到视图层级中，却可以决定有关联的视图之间的布局。</p>
<blockquote>
<p>想象一个场景：三个视图，宽高一样，但是要在父视图中等间距的排列，这是一个很常遇到的需求。</p>
</blockquote>
<p>如果是使用Frame来布局，那就简单了，仅仅是计算问题。但如果是自动布局，那就要增加一些『辅助视图』，『辅助视图』不会显示出来，但是会对布局有帮助，听起来和UILayoutGuide的作用一样，但是辅助视图的缺点就是会渲染到视图层级结构中。现在如果使用UILayoutGuide来实现，这很『简单』。</p>
<img src="/2017/11/17/ios-11/ios_11_uilayoutguide.png" alt="title" title="title">
<p>看起来需要写很多样板代码，如果使用Masonry来进行自动布局，就会减少很多代码。</p>
<p><strong>UILayoutGuide</strong>更多的是用在<strong>UIView</strong>的自动布局中，类似的<strong>UIViewController</strong>中的<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>已经废弃，替换的是使用UIView中的<code>safeAreaLayoutGuide</code>获取layoutGuide：</p>
<img src="/2017/11/17/ios-11/ios_11_layout_guide.png" alt="title" title="title">
<h4 id="Visual_Format_Language"><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="external">Visual Format Language</a></h4><p>Apple在布局方面为方便实现自动布局做的一个语法糖，作用类似于上面的<code>NSLayoutAnchor</code>，可以简洁直观的设置约束。</p>
<h4 id="UIStackView"><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW1" target="_blank" rel="external">UIStackView</a></h4><p>很不巧，这个也是在iOS 9以后提供的。这个类为布局提供了简单的方式:对齐方式、排列方式、填充方式等。从上面导航栏那一节可以知道，在iOS11中导航栏使用自动布局，就是使用的UIStackView的私有子类，而且在自动布局指南中，也有提到UIStackView内部是使用的自动布局技术。</p>
<hr>
<p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/themes/" target="_blank" rel="external">人机界面指南 - 官方</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" target="_blank" rel="external">自动布局指南 - 官方</a></p>
<p><a href="http://www.jianshu.com/p/370d82ba3939" target="_blank" rel="external">你可能需要为你的APP适配iOS11 - 简书</a></p>
<p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/themes/" target="_blank" rel="external">针对iPhone X的适配指南 - 官方</a></p>
<p><a href="https://developer.apple.com/cn/ios/update-apps-for-iphone-x/" target="_blank" rel="external">为 iPhone X 更新您的 app - 官方</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/204/" target="_blank" rel="external">你需要为你的APP适配iOS11 - WWDC session 204</a></p>
<p><a href="http://www.jianshu.com/p/352f101d6df1" target="_blank" rel="external">app界面适配iOS11 - 简书</a></p>
<p><a href="https://cloud.tencent.com/community/article/322940" target="_blank" rel="external">iPhoneX适配实践 - 腾讯云社区</a></p>
<p><a href="http://www.jianshu.com/p/204455df16d6" target="_blank" rel="external">iOS11 &amp; iPhoneX适配总结 - 简书</a></p>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/学习/">学习</a>, <a class="tag-link" href="/tags/自动布局/">自动布局</a></div></article></div><div class="post-nav"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/2017/09/11/hook-wechat/" class="next-post">微信，让生活更美好 	 插件，让微信更方便</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>