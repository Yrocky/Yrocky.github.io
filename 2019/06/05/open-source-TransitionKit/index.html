<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">开源学习之TransitionKit</h1><div class="post-info">2019 6月 5日</div><div class="post-entry"><p>TransitionKit是iOS中对状态机的一个实现，系统本身是有一个状态机的，不过是在GamePlayKit中的，但是针对平常的业务来说并不实用。</p>
<a id="more"></a>
<h2 id="状态机">状态机</h2><p>状态机有四个概念：</p>
<ul>
<li><code>state</code>，状态，一个状态机至少要有2个状态，</li>
<li><code>event</code>，事件，事件就是执行某一个指令，触发某一个状态，会引起状态的变换</li>
<li><code>action</code>，动作，事件发生之后要执行的动作，</li>
<li><code>transition</code>，变换，一个状态变化到另一个状态的抽象过程</li>
</ul>
<p>TransitionKit也根据以上几个概念，抽象出来4个类：</p>
<ul>
<li><code>TKStateMachine</code>，状态机的抽象类，负责管理状态的变化</li>
<li><code>TKState</code>，事件的状态的抽象，在不同时间事物拥有不同的状态</li>
<li><code>TKEvent</code>，引起事件状态变化的指令</li>
<li><code>TKTransition</code>，状态与状态之间变化的过渡</li>
</ul>
<img src="/2019/06/05/open-source-TransitionKit/TransitionKit.png" title="TransitionKit">
<p>在学习这个框架之前，先回忆一下初中学习的知识：水有三种状态：气态、液态、固态，一个比较严谨的说法是气态水（水蒸气）、液态水（常说的水）、固态水（冰）。他们之间可以相互转化，转化之间具体的描述为：</p>
<img src="/2019/06/05/open-source-TransitionKit/water.png" title="water">
<h2 id="TKStateMachine">TKStateMachine</h2><p>这个类是整个状态机的抽象，负责管理状态与状态之间的切换，因此状态机中会有多种状态，以及多种引起状态变化的事件。</p>
<p>根据上面对水的三种状态的描述，使用状态机进行抽象就是，一个状态机（水）有三个状态：gas、liquid、solid，六种事件：g2l（液化）、g2s（凝华）、l2s（凝固）、l2g（气化）、s2l（熔化）、s2g（升华）。</p>
<img src="/2019/06/05/open-source-TransitionKit/water_stateMachine.png" title="water_stateMachine">
<p>三种状态使用该库进行抽象的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TKState *gas = [TKState stateWithName:@&quot;gas&quot;];</span><br><span class="line">[gas setDidEnterStateBlock:^(TKState *state, TKTransition *transition) &#123;</span><br><span class="line">    /// TODO-gas</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">TKState *liquid = [TKState stateWithName:@&quot;liquid&quot;];</span><br><span class="line">[liquid setDidEnterStateBlock:^(TKState *state, TKTransition *transition) &#123;</span><br><span class="line">    /// TODO-liquid</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">TKState *solid = [TKState stateWithName:@&quot;solid&quot;];</span><br><span class="line">[solid setDidEnterStateBlock:^(TKState *state, TKTransition *transition) &#123;</span><br><span class="line">    /// TODO-solid</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>而六种事件的抽象如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TKEvent *g2l = [TKEvent eventWithName:@&quot;g2l&quot; transitioningFromStates:@[gas] toState:liquid];</span><br><span class="line"></span><br><span class="line">TKEvent *g2s = [TKEvent eventWithName:@&quot;g2l&quot;  transitioningFromStates:@[gas] toState:solid];</span><br><span class="line"></span><br><span class="line">TKEvent *l2s = [TKEvent eventWithName:@&quot;l2s&quot;  transitioningFromStates:@[liquid] toState:solid];</span><br><span class="line"></span><br><span class="line">TKEvent *l2g = [TKEvent eventWithName:@&quot;l2g&quot;  transitioningFromStates:@[liquid] toState:gas];</span><br><span class="line"></span><br><span class="line">TKEvent *s2l = [TKEvent eventWithName:@&quot;s2l&quot;  transitioningFromStates:@[solid] toState:liquid];</span><br><span class="line"></span><br><span class="line">TKEvent *s2g = [TKEvent eventWithName:@&quot;s2g&quot;  transitioningFromStates:@[solid] toState:gas];</span><br></pre></td></tr></table></figure>
<p>有了状态和事件，就可以去设置状态机了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TKStateMachine *stateMachine = [[TKStateMachine alloc] init];</span><br><span class="line"></span><br><span class="line">[stateMachine addStates:@[liquid, gas, solid]];</span><br><span class="line">[stateMachine setInitialState:liquid];</span><br><span class="line"></span><br><span class="line">[stateMachine addEvents:@[g2l, g2s, l2s, l2g, s2l, s2g]];</span><br><span class="line">[stateMachine activate];</span><br></pre></td></tr></table></figure>
<p>以上就构建起了水的状态机，前两部分创建对应的<code>状态</code>和<code>事件</code>都是类的实例化，没有什么可探究的。在第三部分，我们创建了状态机，并且将状态和事件都放入状态机中，先看将所有状态都放入状态机以及设置初始状态中都做了什么。</p>
<h2 id="addState">addState</h2><p>状态机添加状态的api有两个，一个是<code>添加单个</code>，一个是<code>添加多个</code>，不过核心api是添加单个状态。</p>
<p>有一点要先说明一下，状态机本身也有两种状态：<code>活跃</code>与<code>非活跃</code>，只有在状态机处于<strong>非活跃状态下才可以对其添加state和event</strong>，只有在<strong>活跃状态下才可以执行event</strong>。</p>
<p>在添加单个state的时候，会对要确保其是TKState或者其子类，并且<code>没有被添加过</code>，然后会放入到状态机的状态集合（mutableStates）中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)addState:(TKState *)state</span><br><span class="line">&#123;</span><br><span class="line">    TKRaiseIfActive();/// 只能在当前状态机不是活跃的时候才可以添加state</span><br><span class="line"></span><br><span class="line">    // 1.传入的state实例必须要是TKState或者其子类</span><br><span class="line">    // 2.state在状态机中没有被添加过</span><br><span class="line">    </span><br><span class="line">    // </span><br><span class="line">    if (self.initialState == nil) self.initialState = state;</span><br><span class="line">    [self.mutableStates addObject:state];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="addEvent">addEvent</h2><p>添加事件要复杂有点儿，先看其api：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)addEvent:(TKEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    // 1.状态机活跃判断、event非空判断</span><br><span class="line"></span><br><span class="line">    // 2.如果event有来源state，要确保当前状态机中已经包含这些state</span><br><span class="line">    if (event.sourceStates) &#123;</span><br><span class="line">        for (TKState *state in event.sourceStates) &#123;</span><br><span class="line">            if (! [self.mutableStates containsObject:state]) &#123;</span><br><span class="line">                // 这里由于状态机的状态集合中没有event的来源state，抛出异常</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.确保当前状态机的states数组中包含 目的state</span><br><span class="line">    // 也就是说event所表示的状态变化只能在当前状态机的state之间</span><br><span class="line">    if (! [self.mutableStates containsObject:event.destinationState]) &#123;</span><br><span class="line">        // 这里由于该event的目的state不包含在状态机的状态集合中，抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">    [self.mutableEvents addObject:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和添加状态一样，添加事件也需要在状态机处于非活跃状态下进行。由于事件表示的是一个状态变化到另一个状态的原因，所以其来<code>源state</code>、<code>目的state</code>都应该在状态机的<code>状态集合中存在</code>，否则就属于逻辑出错， 会抛出异常。</p>
<h2 id="activate">activate</h2><p>开始执行状态机，等待对应的事件来临从而改变状态，其内部将一个表示<code>是否活跃的布尔值</code>进行修改，以及修改<code>当前状态变量（currentState）</code>，并且使用<code>递归锁</code>进行锁定，在修改当前状态的时候会调用block将状态传递出去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 使状态机变活跃，内部会使用锁来确保数据的变化不混乱</span><br><span class="line">- (void)activate</span><br><span class="line">&#123;</span><br><span class="line">    // 如果状态机已经变活跃了，就不能再调用该方法，属于逻辑错误</span><br><span class="line">    if (self.isActive) [NSException raise:NSInternalInconsistencyException format:@&quot;The state machine has already been activated.&quot;];</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line"></span><br><span class="line">    self.active = YES;</span><br><span class="line">    </span><br><span class="line">    // 节点事件回调，方便外部处理逻辑</span><br><span class="line">    if (self.initialState.willEnterStateBlock) self.initialState.willEnterStateBlock(self.initialState, nil);</span><br><span class="line">    </span><br><span class="line">    // 由于状态机是从冷却变为活跃的，所以一定是从初始状态开始的</span><br><span class="line">    self.currentState = self.initialState;</span><br><span class="line">    </span><br><span class="line">    // 节点事件回调，方便外部处理逻辑</span><br><span class="line">    if (self.initialState.didEnterStateBlock) self.initialState.didEnterStateBlock(self.initialState, nil);</span><br><span class="line">    </span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fireEvent">fireEvent</h2><p>经过以上步骤，一个状态机就创建好了，并且<code>处于活跃状态</code>。初始状态机内部的状态改变的原因是<strong>状态机收到了某些事件</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[stateMachine fireEvent:l2g userInfo:nil error:nil];</span><br></pre></td></tr></table></figure>
<p>调用这个代码会执行上面的 <code>/// TODO-gas</code> 回调，由于状态机的当前状态为liquid，所以能引起状态发生改变的事件只有：<strong>l2s</strong>、<strong>l2g</strong>这两个，这个完全符合常识，也完全符合我们这个状态机的规则。</p>
<p>这个api的实现很长，下面会分为三部分来进行讲解，由于这里涉及到对状态机里面集合的get操作，所以会加锁，加锁这部分独立于三部分。</p>
<h3 id="1-获取一个正确的event">1.获取一个正确的event</h3><p>由于第一个参数是TKEvent实例或者event的名字（“g2l”、“g2s”、、），所以这里会先通过这个代码<code>获取到合法的event实例对象</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TKEvent *event = [eventOrEventName isKindOfClass:[TKEvent class]] ? eventOrEventName : [self eventNamed:eventOrEventName];</span><br></pre></td></tr></table></figure>
<p>然后要确保这个<strong>event的源state存在</strong>，并且<strong>当前状态机的状态存在于event的来源state中</strong>，如果不存在则说明不能响应这个event来改变状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (event.sourceStates != nil &amp;&amp;</span><br><span class="line">    ![event.sourceStates containsObject:self.currentState]) &#123;</span><br><span class="line">    NSString *failureReason;// </span><br><span class="line">    NSDictionary *userInfo = @&#123; NSLocalizedDescriptionKey: @&quot;The event cannot be fired from the current state.&quot;, NSLocalizedFailureReasonErrorKey: failureReason &#125;;</span><br><span class="line">    if (error) *error = [NSError errorWithDomain:TKErrorDomain code:TKInvalidTransitionError userInfo:userInfo];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-抽象状态切换">2.抽象状态切换</h3><p>在上一个部分之后，已经获得了一个可以用来改变状态的event，接下来就是要<code>执行状态的修改</code>了，但是在执行状态的修改之前还有一件事要做。</p>
<p>由于event是引起一系列状态到另一个状态改变的抽象，<strong>并不能表示两个具体状态之间的切换</strong>，因此该库使用<code>TKTransition</code>这个类来抽象两个状态之间的转换。</p>
<p>在这一部分，会通过上面的参数来创建一个<code>TKTransition</code>实例对象，然后通过event的一个block回调来决定是否执行该切换:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TKTransition *transition = [TKTransition transitionForEvent:event fromState:self.currentState inStateMachine:self userInfo:userInfo];</span><br><span class="line"></span><br><span class="line">if (event.shouldFireEventBlock) &#123;</span><br><span class="line">    if (! event.shouldFireEventBlock(event, transition)) &#123;</span><br><span class="line"></span><br><span class="line">        // 源代码中这里有一些用于创建error的代码，但是其并没有用，这里忽略</span><br><span class="line"></span><br><span class="line">        [self.lock unlock];</span><br><span class="line"></span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-执行切换状态">3.执行切换状态</h3><p>在经历了一些列艰难险阻之后，状态机终于可以切换状态了。</p>
<p>状态切换，就是要将状态机的<code>currentState</code>属性修改为event的<code>destinationState</code>，因此这里先取出来这两个变量。本来直接将event的destinationState设置给状态机的currentState即可，但是该库提供了很丰富的事件回调，让外部可以有更加细的粒度来处理事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TKState *oldState = self.currentState;</span><br><span class="line">TKState *newState = event.destinationState;</span><br><span class="line"></span><br><span class="line">if (event.willFireEventBlock) event.willFireEventBlock(event, transition);</span><br><span class="line"></span><br><span class="line">if (oldState.willExitStateBlock) oldState.willExitStateBlock(oldState, transition);</span><br><span class="line">if (newState.willEnterStateBlock) newState.willEnterStateBlock(newState, transition);</span><br><span class="line">self.currentState = newState;</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *notificationInfo = [userInfo mutableCopy] ?: [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">// 省略对notiInfo的设置</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:TKStateMachineDidChangeStateNotification object:self userInfo:notificationInfo];</span><br><span class="line"></span><br><span class="line">if (oldState.didExitStateBlock) oldState.didExitStateBlock(oldState, transition);</span><br><span class="line">if (newState.didEnterStateBlock) newState.didEnterStateBlock(newState, transition);</span><br><span class="line"></span><br><span class="line">if (event.didFireEventBlock) event.didFireEventBlock(event, transition);</span><br><span class="line">[self.lock unlock];</span><br></pre></td></tr></table></figure>
<p>至此，状态已经完成了改变。</p>
<p>以上也就是整个状态机框架的实现原理。</p>
<h2 id="参考文章">参考文章</h2><ul>
<li>参考文章列表</li>
</ul>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></article></div><div class="post-nav"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/2019/07/15/open-source-StyledTextKit/" class="prev-post">开源学习之StyledTextKit</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/2019/05/08/four-fundamental-operations-of-arithmetic/" class="next-post">解析一个算术表达式</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>