<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Yrocky's blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">Yrocky</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li></ul></div></nav><main class="prince-container"><div class="articles"><article class="post-block"><h2 class="post-title"><a href="/2020/07/15/use-Responder-Chain-send-event/" class="post-link">基于Responder Chain的对象交互</a></h2><div class="post-info">2020 7月 15日</div><div class="post-entry"><h2 id="问题">问题</h2><p>在直播间中对视图进行解耦的时候，遇到了一个问题：</p>
<blockquote>
<p>因为是将具体业务视图放到对应的contentView中，并且这些业务视图的事件接收方还是当前视图控制器，就会造成事件的传递需要透过contentView这一层。</p>
</blockquote>
<p>如果中间只有contentView这一层还好，可以使用一个多余的delegate或者block将事件转换一下，但如果业务视图自己中也有其他的子控件需要传递事件到视图控制器，那就不止一层了。在软件开发中，只有变和不变，在这里就是如果他有一层，那么就可能有n多层，为了一层提出的方案在n多层中就会显得不那么适用，因为这样并没有解决根本问题。</p>
<img src="/2020/07/15/use-Responder-Chain-send-event/ResponderChain.png" title="ResponderChain">
<p>当然使用通知可以无视事件触发层和处理层之间的距离，但是，通知在我看来不是一个很好的UI通信方式，并且满天飞的通知很难管理。</p></div><div class="post-meta"><a href="/2020/07/15/use-Responder-Chain-send-event/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2020/07/15/use-Self-Manager-make-Module/" class="post-link">Self-Manager模式在业务开发中的组件化应用</a></h2><div class="post-info">2020 7月 15日</div><div class="post-entry"><p><code>Self-Manager</code>直译就是自管理，第一次听说是在孙源的博文中，<strong>基于业务的行为一致，并且具有高复用性，可以将其进行自管理</strong>，这种模式称为Self-Manager模式。作者还举了两个例子，其中用户头像的例子在业务开发中会经常遇到，统一的圆角设计、统一的边距设计、统一的点击跳转等等，通过提供分类这种AOP思想让这个用户头像视图自己决定样式以及行为。</p>
<p>在常规的MVC开发中，会将子视图的<code>样式</code>在自身完成，而<code>行为</code>则上报给上层来处理，这个上层更多的是视图控制器。但是在多地方对视图的使用会使得业务代码很臃肿，行为要一次次的传递个上层，有的甚至要穿越好几层视图。而为这种<code>行为统一</code>的视图提供自己处理事件的能力，能够很好的解决这样的问题，这种思想也很契合组件化的初衷。</p>
<img src="/2020/07/15/use-Self-Manager-make-Module/module_live_home_display.png" title="title"></div><div class="post-meta"><a href="/2020/07/15/use-Self-Manager-make-Module/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/module/">module</a>, <a class="tag-link" href="/tags/组件化/">组件化</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2019/09/05/open-source-PKProtocolExtension/" class="post-link">开源学习之PKProtocolExtension</a></h2><div class="post-info">2019 9月 5日</div><div class="post-entry"><p>在swift中有为协议添加拓展的功能，这个功能可以使协议中的一些方法能够默认实现，这个功能是一个很实用的点，但是在oc中并不支持协议的拓展，<code>PKProtocolExtension</code>这个工具结合runtime为oc提供了’协议拓展’的功能。</p></div><div class="post-meta"><a href="/2019/09/05/open-source-PKProtocolExtension/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2019/07/15/open-source-StyledTextKit/" class="post-link">开源学习之StyledTextKit</a></h2><div class="post-info">2019 7月 15日</div><div class="post-entry"><p>StyledTextKit是一个简单的设置属性字符串的工具，使用builder模式构建，加入了上下文的概念，使得在创建属性字符串的时候能减少很多样板代码。</p></div><div class="post-meta"><a href="/2019/07/15/open-source-StyledTextKit/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2019/06/05/open-source-TransitionKit/" class="post-link">开源学习之TransitionKit</a></h2><div class="post-info">2019 6月 5日</div><div class="post-entry"><p>TransitionKit是iOS中对状态机的一个实现，系统本身是有一个状态机的，不过是在GamePlayKit中的，但是针对平常的业务来说并不实用。</p></div><div class="post-meta"><a href="/2019/06/05/open-source-TransitionKit/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2019/05/08/four-fundamental-operations-of-arithmetic/" class="post-link">解析一个算术表达式</a></h2><div class="post-info">2019 5月 8日</div><div class="post-entry"><p>基于这么多年的学习，看到<code>1+2*3-4</code>这样的表达式，我们可以很快的想到这是一个算数表达式，使用<code>四则运算的法则</code>就可以得到最后的结果为<code>2</code>，这仅仅是由于我们固定思维（或者是学习沉淀）得出来的结果。如果将这一段字符串交给计算机，并且让它输出我们想要的结果，计算后的结果，就需要将四则运算法则告诉计算机，然后根据这个规则来解析这个表达式，最后它才能给出来我们想要的结果。</p>
<p>从一个纯文本表达式到最后正确的结果这个过程，可以理解为是一个翻译，将文本翻译成算术表达式，在四则运算的规则下，对这个表达式进行它语法下的运算，最后得出正确的结果。</p>
<p>这个简单的四则运算仅仅是一个缩影，往大了就会涉及到json的解析、解释器模式、编程语言的编译等等。这篇文章就将从解析一个算术表达式开始，来对涉及到的深层知识做一个整理。</p></div><div class="post-meta"><a href="/2019/05/08/four-fundamental-operations-of-arithmetic/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/学习/">学习</a>, <a class="tag-link" href="/tags/数据结构/">数据结构</a>, <a class="tag-link" href="/tags/设计模式/">设计模式</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2019/04/13/open-source-YYAsyncLayer/" class="post-link">开源学习之YYAsyncLayer</a></h2><div class="post-info">2019 4月 13日</div><div class="post-entry"><p>YYAsyncLayer是YYKit中提供的一个可以在异步绘制内容的CALayer子类，通过将layer绘制部分放入异步线程中进行达到提升性能的目的。</p></div><div class="post-meta"><a href="/2019/04/13/open-source-YYAsyncLayer/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2019/03/23/open-source-DZNEmptyDataSet/" class="post-link">开源学习之DZNEmptyDataSet</a></h2><div class="post-info">2019 3月 23日</div><div class="post-entry"><p>这是一个为UITableView、UICollectionView在无数据状态下提供空态展示视图的组件，由于他们的父类都是UIScrollView，所以作者通过为UIScrollView提供分类接口来达到兼容两者的效果，接口头文件很简洁，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface UIScrollView (EmptyDataSet)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak, nullable) IBOutlet id &lt;DZNEmptyDataSetSource&gt; emptyDataSetSource;</span><br><span class="line">@property (nonatomic, weak, nullable) IBOutlet id &lt;DZNEmptyDataSetDelegate&gt; emptyDataSetDelegate;</span><br><span class="line">@property (nonatomic, readonly, getter = isEmptyDataSetVisible) BOOL emptyDataSetVisible;</span><br><span class="line"></span><br><span class="line">- (void)reloadEmptyDataSet;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><div class="post-meta"><a href="/2019/03/23/open-source-DZNEmptyDataSet/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2019/03/05/open-source-FDFullscreenPopGesture/" class="post-link">开源学习之FDFullscreenPopGesture</a></h2><div class="post-info">2019 3月 5日</div><div class="post-entry"><p>这是为解决视图导航中显示导航栏与否，以及支持全屏pop手势的一个很小巧的组件，是foxingdog团队出品的一款基于<code>runtime</code>+<code>KVC</code>原理实现的优雅解决方案。</p></div><div class="post-meta"><a href="/2019/03/05/open-source-FDFullscreenPopGesture/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/开源学习/">开源学习</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2018/07/03/what-is-apple-in-ai/" class="post-link">Apple在机器学习领域都做了什么</a></h2><div class="post-info">2018 7月 3日</div><div class="post-entry"><p>众所周知，在WWDC2018上提出的Create CoreML让很多iOS开发者徘徊在入门人工智能的门槛前减少了一些顾虑，Apple正在为我们提供更加简单的方式来使用人工智能解决问题。不得不承认，这是苹果一贯的作风：<strong>将复杂问题简单化</strong>。而在WWDC2017的时候就推出了<code>Core ML</code>这个机器学习框架，不过由于当时的注意点不在人工智能上，而是新推出的iOS11系统以及iPhone X的适配，当时仅仅是看了一下session，没有细致的学习，时隔一年再次接触Core ML发现，系统提供的Core ML的友好程度是其他第三方无法提供的，虽然Core ML还有诸多的不足，但是官方现在正在一步步的进行优化中。</p>
<p>下面就对Apple这几年公布的涉及到人工智能的框架进行一个梳理，即作为对这一段时间的学习总结，也为身为iOS开发人员如何无痛的进入人工智能列举一些学习资源。</p>
<img src="/2018/07/03/what-is-apple-in-ai/ml_title_cloud.png" title="title"></div><div class="post-meta"><a href="/2018/07/03/what-is-apple-in-ai/" class="article-more">阅读更多</a><div class="post-tags-box"><a class="tag-link" href="/tags/AI/">AI</a>, <a class="tag-link" href="/tags/Core-ML/">Core ML</a>, <a class="tag-link" href="/tags/ML/">ML</a></div></div></article></div><div class="paginator"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/page/2/" class="next-page">下一页</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;Yrocky&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>